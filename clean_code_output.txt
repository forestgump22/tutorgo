========================================
Y aqui esta toda la parte del backend :D
recuerda recordar todo super bien porfas
========================================

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\TutorgoApplication.java
package tutorgo.com;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;
@SpringBootApplication
@EnableScheduling
public class TutorgoApplication {
    public static void main(String[] args) {
        SpringApplication.run(TutorgoApplication.class, args);
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\config\SecurityConfig.java
package tutorgo.com.config;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import tutorgo.com.security.JwtAuthenticationEntryPoint;
import tutorgo.com.security.JwtAuthenticationFilter;
import java.util.Arrays;
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {
    private final JwtAuthenticationEntryPoint authenticationEntryPoint;
    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    @Bean
    public static PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) throws Exception {
        return configuration.getAuthenticationManager();
    }
    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(authorize -> authorize
                        .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                        .requestMatchers("/auth/**").permitAll()
                        .requestMatchers("/error").permitAll()
                        .requestMatchers(HttpMethod.GET, "/tutores/**").permitAll()
                        .requestMatchers(HttpMethod.GET, "/tutores/{id}").authenticated()
                        .requestMatchers(HttpMethod.GET, "/notificaciones/mis-notificaciones").authenticated()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .exceptionHandling(exception -> exception
                        .authenticationEntryPoint(authenticationEntryPoint))
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }
    @Bean
    CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type", "X-Requested-With", "accept", "Origin", "Access-Control-Request-Method", "Access-Control-Request-Headers"));
        configuration.setExposedHeaders(Arrays.asList("Authorization"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\controller\AuthController.java
package tutorgo.com.controller;
import tutorgo.com.dto.request.LoginRequest;
import tutorgo.com.dto.request.UserRegistrationRequest;
import tutorgo.com.dto.response.ApiResponse;
import tutorgo.com.dto.response.JwtAuthenticationResponse;
import tutorgo.com.dto.response.UserResponse;
import tutorgo.com.service.AuthService;
import tutorgo.com.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {
    private final UserService userService;
    private final AuthService authService;
    @PostMapping("/register")
    public ResponseEntity<ApiResponse> registerUser(@Valid @RequestBody UserRegistrationRequest registrationRequest) {
        UserResponse userResponse = userService.registerUser(registrationRequest);
        ApiResponse apiResponse = new ApiResponse(true, "¡Registro exitoso! Ahora puedes iniciar sesión.", userResponse);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }
    @PostMapping("/login")
    public ResponseEntity<JwtAuthenticationResponse> loginUser(@Valid @RequestBody LoginRequest loginRequest) {
        JwtAuthenticationResponse jwtResponse = authService.loginUser(loginRequest);
        return ResponseEntity.ok(jwtResponse);
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\controller\DisponibilidadController.java
package tutorgo.com.controller;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;
import tutorgo.com.dto.request.DisponibilidadRequest;
import tutorgo.com.dto.response.ApiResponse;
import tutorgo.com.dto.response.DisponibilidadResponse;
import tutorgo.com.service.DisponibilidadService;
import java.util.List;
@RestController
@RequestMapping("/tutores/me/disponibilidades")
@RequiredArgsConstructor
@PreAuthorize("hasRole('TUTOR')")
public class DisponibilidadController {
    private final DisponibilidadService disponibilidadService;
    private String getAuthenticatedTutorEmail() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return ((UserDetails) authentication.getPrincipal()).getUsername();
    }
    @PostMapping
    public ResponseEntity<ApiResponse> addDisponibilidad(@Valid @RequestBody DisponibilidadRequest request) {
        String tutorEmail = getAuthenticatedTutorEmail();
        DisponibilidadResponse response = disponibilidadService.addDisponibilidad(tutorEmail, request);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(new ApiResponse(true, "Disponibilidad agregada correctamente.", response));
    }
    @GetMapping
    public ResponseEntity<List<DisponibilidadResponse>> getMisDisponibilidades() {
        String tutorEmail = getAuthenticatedTutorEmail();
        List<DisponibilidadResponse> disponibilidades = disponibilidadService.getDisponibilidadesByTutor(tutorEmail);
        if (disponibilidades.isEmpty()){
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.ok(disponibilidades);
    }
    @PutMapping("/{disponibilidadId}")
    public ResponseEntity<ApiResponse> updateDisponibilidad(
            @PathVariable Long disponibilidadId,
            @Valid @RequestBody DisponibilidadRequest request) {
        String tutorEmail = getAuthenticatedTutorEmail();
        DisponibilidadResponse response = disponibilidadService.updateDisponibilidad(tutorEmail, disponibilidadId, request);
        return ResponseEntity.ok(new ApiResponse(true, "Disponibilidad actualizada correctamente.", response));
    }
    @DeleteMapping("/{disponibilidadId}")
    public ResponseEntity<ApiResponse> deleteDisponibilidad(@PathVariable Long disponibilidadId) {
        String tutorEmail = getAuthenticatedTutorEmail();
        disponibilidadService.deleteDisponibilidad(tutorEmail, disponibilidadId);
        return ResponseEntity.ok(new ApiResponse(true, "Disponibilidad eliminada correctamente."));
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\controller\EnlaceSesionController.java
package tutorgo.com.controller;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import tutorgo.com.dto.request.EnlaceSesionRequestDTO;
import tutorgo.com.dto.response.EnlaceSesionResponseDTO;
import tutorgo.com.service.EnlaceSesionService;
import java.util.List;
import static tutorgo.com.security.SecurityUtil.extractUserEmail;
@RestController
@RequestMapping("/sesiones/{sesionId}/enlaces")
@RequiredArgsConstructor
@PreAuthorize("hasRole('TUTOR')")
public class EnlaceSesionController {
    private final EnlaceSesionService enlaceSesionService;
    @PostMapping
    public ResponseEntity<List<EnlaceSesionResponseDTO>> guardarEnlaces(
            @PathVariable Long sesionId,
            @RequestBody List<EnlaceSesionRequestDTO> enlacesDTO,
            Authentication authentication) {
        String emailTutor = extractUserEmail(authentication);
        List<EnlaceSesionResponseDTO> guardados = enlaceSesionService.guardarEnlaces(sesionId, enlacesDTO, emailTutor);
        return ResponseEntity.ok(guardados);
    }
    @DeleteMapping("/{id}")
    public ResponseEntity<String> eliminarEnlace(
            @PathVariable Long id,
            Authentication authentication) {
        String emailTutor = extractUserEmail(authentication);
        enlaceSesionService.eliminarEnlacePorId(id, emailTutor);
        return ResponseEntity.ok("Enlace eliminado correctamente");
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\controller\NotificacionController.java
package tutorgo.com.controller;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import tutorgo.com.dto.response.NotificacionResponse;
import tutorgo.com.service.NotificacionService;
import java.util.List;
@RestController
@RequestMapping("/notificaciones")
@RequiredArgsConstructor
public class NotificacionController {
    private final NotificacionService notificacionService;
    @GetMapping("/mis-notificaciones")
    public ResponseEntity<List<NotificacionResponse>> getMisNotificaciones(Authentication authentication) {
        String email = authentication.getName();
        List<NotificacionResponse> notificaciones = notificacionService.getMisNotificaciones(email);
        if (notificaciones.isEmpty()) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.ok(notificaciones);
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\controller\PagoController.java
package tutorgo.com.controller;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import tutorgo.com.dto.response.PagoResponse;
import tutorgo.com.service.PagoService;
import tutorgo.com.model.User;
import tutorgo.com.repository.UserRepository;
import tutorgo.com.model.Estudiante;
import tutorgo.com.model.Tutor;
import tutorgo.com.repository.EstudianteRepository;
import tutorgo.com.repository.TutorRepository;
import java.util.List;
@RestController
@RequestMapping("/pagos")
@RequiredArgsConstructor
public class PagoController {
    private final PagoService pagoService;
    private final UserRepository userRepository;
    private final EstudianteRepository estudianteRepository;
    private final TutorRepository tutorRepository;
    @GetMapping("/historial")
    public ResponseEntity<?> getHistorialTransacciones() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String userEmail = authentication.getName();
        User user = userRepository.findByEmail(userEmail).orElse(null);
        if (user == null) {
            return ResponseEntity.status(401).body("No autorizado");
        }
        String tipoUsuario = "";
        if (estudianteRepository.findByUser(user).isPresent()) {
            tipoUsuario = "estudiante";
        } else if (tutorRepository.findByUser(user).isPresent()) {
            tipoUsuario = "tutor";
        } else {
            return ResponseEntity.status(403).body("Usuario no tiene rol válido");
        }
        try {
            List<PagoResponse> historial = pagoService.obtenerHistorialTransacciones(userEmail);
            if (historial.isEmpty()) {
                return ResponseEntity.ok().body("Aún no tienes transacciones registradas");
            }
            return ResponseEntity.ok().body(historial);
        } catch (Exception e) {
            return ResponseEntity.status(500).body("No se pudo cargar tu historial de pagos. Intenta nuevamente más tarde");
        }
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\controller\ResenaController.java
package tutorgo.com.controller;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import tutorgo.com.dto.request.ResenaRequestDTO;
import tutorgo.com.dto.response.ResenaResponseDTO;
import tutorgo.com.service.ResenaService;
import static tutorgo.com.security.SecurityUtil.extractUserEmail;
@RestController
@RequestMapping("/resenas")
@RequiredArgsConstructor
@PreAuthorize("hasRole('ESTUDIANTE')") // Solo estudiantes pueden calificar
public class ResenaController {
    private final ResenaService resenaService;
    @PostMapping("/sesion/{sesionId}")
    public ResponseEntity<ResenaResponseDTO> crearResena(
            @PathVariable Long sesionId,
            @RequestBody ResenaRequestDTO requestDTO,
            Authentication authentication) {
        String emailEstudiante = extractUserEmail(authentication);
        ResenaResponseDTO response = resenaService.crearResena(sesionId, requestDTO, emailEstudiante);
        return ResponseEntity.ok(response);
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\controller\SesionController.java
package tutorgo.com.controller;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;
import tutorgo.com.dto.request.ReservaTutoriaRequest;
import tutorgo.com.dto.response.ApiResponse;
import tutorgo.com.dto.response.PagoResponse;
import tutorgo.com.dto.response.SesionResponse;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.service.SesionService;
import tutorgo.com.dto.request.ConfirmarPagoRequest; // Nueva importación
import tutorgo.com.service.PagoService;
import java.util.List;
@RestController
@RequestMapping("/sesiones")
@RequiredArgsConstructor
public class SesionController {
    private final SesionService sesionService;
    private final PagoService pagoService; // Inyectar PagoService
    @PostMapping
    public ResponseEntity<ApiResponse> reservarTutoria(@Valid @RequestBody ReservaTutoriaRequest request) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String alumnoEmail = ((UserDetails) authentication.getPrincipal()).getUsername();
        SesionResponse sesionResponse = sesionService.reservarTutoria(alumnoEmail, request);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(new ApiResponse(true, "Tu solicitud ha sido enviada. El tutor la confirmará pronto.", sesionResponse));
    }
    @GetMapping("/mis-solicitudes")
    @PreAuthorize("hasRole('ESTUDIANTE')")
    public ResponseEntity<List<SesionResponse>> getMisSolicitudes() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String alumnoEmail = ((UserDetails) authentication.getPrincipal()).getUsername();
        List<SesionResponse> sesiones = sesionService.getSesionesByAlumnoEmail(alumnoEmail);
        if (sesiones.isEmpty()) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.ok(sesiones);
    }
    @GetMapping("/mis-clases")
    @PreAuthorize("hasRole('TUTOR')")
    public ResponseEntity<List<SesionResponse>> getMisClases() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String tutorEmail = ((UserDetails) authentication.getPrincipal()).getUsername();
        List<SesionResponse> sesiones = sesionService.getSesionesByTutorEmail(tutorEmail);
        if (sesiones.isEmpty()) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.ok(sesiones);
    }
    @PostMapping("/{sesionId}/pagos") // Ej: POST /api/sesiones/123/pagos
    public ResponseEntity<ApiResponse> confirmarPagoYReservar(
            @PathVariable Long sesionId, // sesionId viene del path
            @Valid @RequestBody ConfirmarPagoRequest pagoDetails) {
        if (!sesionId.equals(pagoDetails.getSesionId())) {
            throw new BadRequestException("El ID de la sesión en el path y en el cuerpo de la solicitud no coinciden.");
        }
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String alumnoEmail = ((UserDetails) authentication.getPrincipal()).getUsername();
        PagoResponse pagoResponse = pagoService.procesarPagoYConfirmarSesion(alumnoEmail, pagoDetails);
        return ResponseEntity.ok(new ApiResponse(true, "Pago exitoso. Te esperamos en la tutoría.", pagoResponse));
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\controller\SesionProgramadaController.java
package tutorgo.com.controller;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;
import tutorgo.com.dto.response.SesionProgramadaResponseDTO;
import tutorgo.com.service.SesionProgramadaService;
@RestController
@RequestMapping("/sesiones/programada")
@RequiredArgsConstructor
public class SesionProgramadaController {
    private final SesionProgramadaService sesionProgramadaService;
    @GetMapping("/mi-sesion")
    public ResponseEntity<SesionProgramadaResponseDTO> obtenerMiSesionProgramada() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String emailAutenticado = obtenerEmailAutenticado(authentication);
        SesionProgramadaResponseDTO respuesta = sesionProgramadaService.obtenerSesionProgramadaDelEstudianteAutenticado(emailAutenticado);
        return ResponseEntity.ok(respuesta);
    }
    private String obtenerEmailAutenticado(Authentication authentication) {
        if (authentication == null || !authentication.isAuthenticated() || authentication.getPrincipal().equals("anonymousUser")) {
            throw new RuntimeException("Usuario no autenticado.");
        }
        Object principal = authentication.getPrincipal();
        if (principal instanceof UserDetails userDetails) {
            return userDetails.getUsername();
        } else {
            return principal.toString();
        }
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\controller\TutorController.java
package tutorgo.com.controller;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.security.access.prepost.PreAuthorize;
import tutorgo.com.dto.response.ApiResponse;
import tutorgo.com.dto.response.PagedResponse;
import tutorgo.com.dto.response.TutorSummaryResponse;
import tutorgo.com.dto.response.TutorProfileResponse;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.service.TutorService;
import tutorgo.com.utils.AppConstants;
import tutorgo.com.dto.response.DisponibilidadResponse;
import tutorgo.com.service.DisponibilidadService;
import java.util.List;
@RestController
@RequestMapping("/tutores")
@RequiredArgsConstructor
public class TutorController {
    private final TutorService tutorService;
    private final DisponibilidadService disponibilidadService;
    @GetMapping
    public ResponseEntity<?> getAllTutores(
            @RequestParam(value = "query", required = false) String query,
            @RequestParam(value = "maxPrecio", required = false) Integer maxPrecio,
            @RequestParam(value = "puntuacion", required = false) Float puntuacion,
            @RequestParam(value = "page", defaultValue = AppConstants.DEFAULT_PAGE_NUMBER) int page,
            @RequestParam(value = "size", defaultValue = "9") int size,
            @RequestParam(value = "sortBy", defaultValue = AppConstants.DEFAULT_SORT_BY_TUTOR) String sortBy,
            @RequestParam(value = "sortDir", defaultValue = AppConstants.DEFAULT_SORT_DIRECTION) String sortDir
    ) {
        Sort.Direction direction = sortDir.equalsIgnoreCase("desc") ? Sort.Direction.DESC : Sort.Direction.ASC;
        Pageable pageable = PageRequest.of(page, size, Sort.by(direction, sortBy));
        PagedResponse<TutorSummaryResponse> response = tutorService.getAllTutores(query, maxPrecio, puntuacion, pageable);
        return ResponseEntity.ok(response);
    }
    @GetMapping("/{id}")
    public ResponseEntity<?> getTutorProfile(@PathVariable Long id) {
        try {
            TutorProfileResponse response = tutorService.getTutorProfile(id);
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException ex) {
            return ResponseEntity.badRequest().body(new ApiResponse(false, "No se pudo cargar el perfil completo del tutor"));
        }
    }
    @GetMapping("/{tutorId}/disponibilidades")
    @PreAuthorize("isAuthenticated()") // Solo usuarios logueados (estudiantes) pueden verla
    public ResponseEntity<List<DisponibilidadResponse>> getDisponibilidadesDeTutor(@PathVariable Long tutorId) {
        List<DisponibilidadResponse> disponibilidades = disponibilidadService.getDisponibilidadesByTutorId(tutorId);
        if (disponibilidades.isEmpty()) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.ok(disponibilidades);
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\controller\UserController.java
package tutorgo.com.controller;
import org.springframework.web.bind.annotation.*;
import tutorgo.com.dto.request.UpdateUserProfileRequest;
import tutorgo.com.dto.response.UserResponse;
import org.springframework.http.HttpStatus;
import tutorgo.com.dto.request.UpdatePasswordRequest;
import tutorgo.com.dto.response.ApiResponse;
import tutorgo.com.model.User;
import tutorgo.com.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.data.domain.PageRequest; // Nuevos imports
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {
    private final UserService userService;
    @PutMapping("/me/password")
    public ResponseEntity<ApiResponse> updateUserPassword(@Valid @RequestBody UpdatePasswordRequest updatePasswordRequest) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String userEmail = extractUserEmail(authentication);
        userService.updatePassword(userEmail, updatePasswordRequest);
        return ResponseEntity.ok(new ApiResponse(true, "Contraseña actualizada con éxito."));
    }
    @PutMapping("/me/profile")
    public ResponseEntity<ApiResponse> updateUserProfile(@Valid @RequestBody UpdateUserProfileRequest updateUserProfileRequest) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String userEmail = extractUserEmail(authentication);
        UserResponse updatedUser = userService.updateUserProfile(userEmail, updateUserProfileRequest);
        return ResponseEntity.ok(new ApiResponse(true, "Perfil actualizado correctamente.", updatedUser));
    }
    @DeleteMapping("/me")
    public ResponseEntity<ApiResponse> deleteCurrentUserProfile() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String userEmail = extractUserEmail(authentication);
        userService.deleteUserProfile(userEmail);
        return ResponseEntity.ok(new ApiResponse(true, "Tu cuenta ha sido eliminada exitosamente."));
    }
    private String extractUserEmail(Authentication authentication) {
        if (authentication == null || !authentication.isAuthenticated() || "anonymousUser".equals(authentication.getPrincipal())) {
            throw new org.springframework.security.access.AccessDeniedException("Usuario no autenticado.");
        }
        Object principal = authentication.getPrincipal();
        if (principal instanceof UserDetails) {
            return ((UserDetails) principal).getUsername();
        } else if (principal != null) {
            return principal.toString();
        }
        throw new IllegalStateException("No se pudo determinar el email del usuario autenticado desde el principal.");
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\request\ConfirmarPagoRequest.java
package tutorgo.com.dto.request;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import tutorgo.com.enums.MetodoPagoEnum; // Asegúrate que este enum exista
@Data
public class ConfirmarPagoRequest {
    @NotNull(message = "El ID de la sesión es obligatorio")
    private Long sesionId;
    @NotNull(message = "El método de pago es obligatorio")
    private MetodoPagoEnum metodoPago;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\request\DisponibilidadRequest.java
package tutorgo.com.dto.request;
import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import java.time.LocalDate;
import java.time.LocalTime;
@Data
public class DisponibilidadRequest {
    @NotNull(message = "La fecha es obligatoria")
    @FutureOrPresent(message = "La fecha de disponibilidad no puede ser en el pasado")
    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate fecha;
    @NotNull(message = "La hora de inicio es obligatoria")
    @JsonFormat(pattern = "HH:mm:ss") // o HH:mm
    private LocalTime horaInicio;
    @NotNull(message = "La hora de finalización es obligatoria")
    @JsonFormat(pattern = "HH:mm:ss") // o HH:mm
    private LocalTime horaFinal;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\request\EnlaceSesionRequestDTO.java
package tutorgo.com.dto.request;
import lombok.Data;
@Data
public class EnlaceSesionRequestDTO {
    private String nombre;
    private String enlace;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\request\LoginRequest.java
package tutorgo.com.dto.request;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;
@Data
public class LoginRequest {
    @NotBlank(message = "El correo electrónico es obligatorio")
    @Email(message = "El formato del correo electrónico no es válido")
    private String email;
    @NotBlank(message = "La contraseña es obligatoria")
    private String password; 
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\request\ResenaRequestDTO.java
package tutorgo.com.dto.request;
import lombok.Data;
@Data
public class ResenaRequestDTO {
    private Integer calificacion;
    private String comentario;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\request\ReservaTutoriaRequest.java
package tutorgo.com.dto.request;
import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import java.time.LocalDate;
import java.time.LocalTime;
@Data
public class ReservaTutoriaRequest {
    @NotNull(message = "El ID del tutor es obligatorio")
    private Long tutorId;
    @NotNull(message = "La fecha de la tutoría es obligatoria")
    @FutureOrPresent(message = "La fecha de la tutoría no puede ser en el pasado")
    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate fecha;
    @NotNull(message = "La hora de inicio es obligatoria")
    @JsonFormat(pattern = "HH:mm:ss")
    private LocalTime horaInicio;
    @NotNull(message = "La hora de finalización es obligatoria")
    @JsonFormat(pattern = "HH:mm:ss")
    private LocalTime horaFinal;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\request\UpdatePasswordRequest.java
package tutorgo.com.dto.request;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
@Data
public class UpdatePasswordRequest {
    @NotBlank(message = "La contraseña actual es obligatoria")
    private String currentPassword;
    @NotBlank(message = "La nueva contraseña es obligatoria")
    @Size(min = 8, message = "La nueva contraseña debe tener al menos 8 caracteres")
    private String newPassword;
    @NotBlank(message = "La confirmación de la nueva contraseña es obligatoria")
    private String confirmNewPassword;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\request\UpdateUserProfileRequest.java
package tutorgo.com.dto.request;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import org.hibernate.validator.constraints.URL;
@Data
public class UpdateUserProfileRequest {
    @NotBlank(message = "El nombre completo es obligatorio")
    @Size(min = 2, max = 150, message = "El nombre debe tener entre 2 y 150 caracteres")
    private String nombre;
    @URL(message = "El formato de la URL de la foto no es válido")
    @Size(max = 255, message = "La URL de la foto no debe exceder los 255 caracteres")
    private String fotoUrl;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\request\UserRegistrationRequest.java
package tutorgo.com.dto.request;
import tutorgo.com.enums.RoleName;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;
@Data
public class UserRegistrationRequest {
    @NotBlank(message = "El nombre es obligatorio")
    @Size(min = 2, max = 150, message = "El nombre debe tener entre 2 y 150 caracteres")
    private String nombre;
    @NotBlank(message = "El correo electrónico es obligatorio")
    @Email(message = "El formato del correo electrónico no es válido")
    @Size(max = 150, message = "El correo no debe exceder los 150 caracteres")
    private String email;
    @NotBlank(message = "La contraseña es obligatoria")
    @Size(min = 8, message = "La contraseña debe tener al menos 8 caracteres")
    private String password;
    @NotNull(message = "El rol es obligatorio")
    private RoleName rol;
    private String centroEstudio;
    private Integer tarifaHora;
    private String rubro;
    private String bio;
    private String fotoUrl;
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\ApiResponse.java
package tutorgo.com.dto.response;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse {
    private boolean success;
    private String message;
    private Object data;
    public ApiResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\DisponibilidadResponse.java
package tutorgo.com.dto.response;
import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;
import java.time.LocalDate;
import java.time.LocalDateTime;
@Data
public class DisponibilidadResponse {
    private Long id;
    private Long tutorId; // Para confirmar a qué tutor pertenece
    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate fecha;
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime horaInicial; // En la entidad es Timestamp
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime horaFinal;   // En la entidad es Timestamp
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\EnlaceSesionResponseDTO.java
package tutorgo.com.dto.response;
import lombok.Data;
@Data
public class EnlaceSesionResponseDTO {
    private Long id;
    private String nombre;
    private String enlace;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\JwtAuthenticationResponse.java
package tutorgo.com.dto.response;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
@Data
@NoArgsConstructor
@AllArgsConstructor
public class JwtAuthenticationResponse {
    private String accessToken;
    private String tokenType = "Bearer";
    private UserResponse user;
    public JwtAuthenticationResponse(String accessToken, UserResponse user) {
        this.accessToken = accessToken;
        this.user = user;
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\NotificacionResponse.java
package tutorgo.com.dto.response;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;
@Data
@NoArgsConstructor
@AllArgsConstructor
public class NotificacionResponse {
    private Long id;
    private String titulo;
    private String texto;
    private String tipo;
    private LocalDateTime fechaCreacion;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\PagedResponse.java
package tutorgo.com.dto.response;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PagedResponse<T> {
    private List<T> content;
    private int pageNumber;
    private int pageSize;
    private long totalElements;
    private int totalPages;
    private boolean last;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\PagoResponse.java
package tutorgo.com.dto.response;
import lombok.Data;
import tutorgo.com.enums.EstadoPagoEnum;
import tutorgo.com.enums.MetodoPagoEnum;
import java.math.BigDecimal;
import java.time.LocalDateTime;
@Data
public class PagoResponse {
    private Long id;
    private Long tutorId;
    private Long estudianteId;
    private BigDecimal monto;
    private BigDecimal comisionPlataforma;
    private MetodoPagoEnum metodoPago;
    private EstadoPagoEnum tipoEstado;
    private Long sesionId;
    private LocalDateTime fechaPago;
    private String descripcion;
    private String nombreTutor;
    private String nombreEstudiante;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\ResenaResponseDTO.java
package tutorgo.com.dto.response;
import lombok.Data;
@Data
public class ResenaResponseDTO {
    private Long id;
    private Integer calificacion;
    private String comentario;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\SesionProgramadaResponseDTO.java
package tutorgo.com.dto.response;
import lombok.Data;
import java.util.List;
@Data
public class SesionProgramadaResponseDTO {
    private Long sesionId;
    private boolean enlaceDisponible;
    private String mensaje;
    private List<EnlaceSesionResponseDTO> enlaces;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\SesionResponse.java
package tutorgo.com.dto.response;
import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;
import tutorgo.com.enums.EstadoSesionEnum;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
@Data
public class SesionResponse {
    private Long id;
    private Long tutorId;
    private String nombreTutor;
    private Long estudianteId;
    private String nombreEstudiante;
    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate fecha;
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime horaInicial;
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime horaFinal;
    private EstadoSesionEnum tipoEstado;
    private List<EnlaceSesionResponseDTO> enlaces;
    private boolean fueCalificada;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\StudentProfileResponse.java
package tutorgo.com.dto.response;
import lombok.Data;
@Data
public class StudentProfileResponse {
    private Long id;
    private String centroEstudio;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\TutorProfileResponse.java
package tutorgo.com.dto.response;
import lombok.Data;
@Data
public class TutorProfileResponse {
    private Long id;
    private String nombreUsuario;
    private String fotoUrlUsuario;
    private Integer tarifaHora;
    private String rubro;
    private String bio;
    private Float estrellasPromedio;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\TutorSummaryResponse.java
package tutorgo.com.dto.response;
import lombok.Data;
@Data
public class TutorSummaryResponse {
    private Long tutorId;
    private String nombreUsuario;
    private String fotoUrlUsuario;
    private String rubro;
    private Float estrellasPromedio;
    private Integer tarifaHora;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\dto\response\UserResponse.java
package tutorgo.com.dto.response;
import tutorgo.com.enums.RoleName;
import lombok.Data;
@Data
public class UserResponse {
    private Long id;
    private String nombre;
    private String email;
    private RoleName rol;
    private String fotoUrl;
    private TutorProfileResponse tutorProfile;
    private StudentProfileResponse studentProfile;
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\enums\EstadoPagoEnum.java
package tutorgo.com.enums;
public enum EstadoPagoEnum {
    COMPLETADO,
    PENDIENTE,
    FALLIDO
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\enums\EstadoSesionEnum.java
package tutorgo.com.enums;
public enum EstadoSesionEnum {
    CONFIRMADO,
    PENDIENTE
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\enums\MetodoPagoEnum.java
package tutorgo.com.enums;
public enum MetodoPagoEnum {
    TARJETA_CREDITO,
    PAYPAL,
    TRANSFERENCIA
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\enums\RoleName.java
package tutorgo.com.enums;
public enum RoleName {
    ADMIN,
    TUTOR,
    ESTUDIANTE
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\enums\TipoNotificacionEstEnum.java
package tutorgo.com.enums;
public enum TipoNotificacionEstEnum {
    RECORDATORIO,
    CONFIRMACION,
    PAGO
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\enums\TipoNotificacionTutorEnum.java
package tutorgo.com.enums;
public enum TipoNotificacionTutorEnum {
    RECORDATORIO,
    RESERVA,
    CONFIRMACION
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\exception\BadRequestException.java
package tutorgo.com.exception;
public class BadRequestException extends RuntimeException {
    public BadRequestException(String message) {
        super(message);
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\exception\DuplicateResourceException.java
package tutorgo.com.exception;
public class DuplicateResourceException extends RuntimeException {
    public DuplicateResourceException(String message) {
        super(message);
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\exception\ForbiddenException.java
package tutorgo.com.exception;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
@ResponseStatus(HttpStatus.FORBIDDEN)
public class ForbiddenException extends RuntimeException {
    public ForbiddenException(String message) {
        super(message);
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\exception\GlobalExceptionHandler.java
package tutorgo.com.exception;
import tutorgo.com.dto.response.ApiResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import java.util.HashMap;
import java.util.Map;
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse> handleResourceNotFoundException(ResourceNotFoundException ex) {
        ApiResponse apiResponse = new ApiResponse(false, ex.getMessage());
        return new ResponseEntity<>(apiResponse, HttpStatus.NOT_FOUND);
    }
    @ExceptionHandler(DuplicateResourceException.class)
    public ResponseEntity<ApiResponse> handleDuplicateResourceException(DuplicateResourceException ex) {
        ApiResponse apiResponse = new ApiResponse(false, ex.getMessage());
        return new ResponseEntity<>(apiResponse, HttpStatus.CONFLICT);
    }
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ApiResponse> handleBadRequestException(BadRequestException ex) {
        ApiResponse apiResponse = new ApiResponse(false, ex.getMessage());
        return new ResponseEntity<>(apiResponse, HttpStatus.BAD_REQUEST);
    }
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        String firstErrorMessage = errors.values().stream().findFirst().orElse(ex.getMessage());
        ApiResponse apiResponse = new ApiResponse(false, "Error de validación. Verifique los campos.", errors);
        return new ResponseEntity<>(apiResponse, HttpStatus.BAD_REQUEST);
    }
    @ExceptionHandler(BadCredentialsException.class) // Para HU2: Iniciar Sesión
    public ResponseEntity<ApiResponse> handleBadCredentialsException(BadCredentialsException ex) {
        ApiResponse apiResponse = new ApiResponse(false, "Credenciales inválidas. Pruebe de nuevo.");
        return new ResponseEntity<>(apiResponse, HttpStatus.UNAUTHORIZED);
    }
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiResponse> handleAccessDeniedException(AccessDeniedException ex) {
        ApiResponse apiResponse = new ApiResponse(false, "Acceso denegado.");
        return new ResponseEntity<>(apiResponse, HttpStatus.FORBIDDEN);
    }
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse> handleGlobalException(Exception ex) {
        ex.printStackTrace();
        ApiResponse apiResponse = new ApiResponse(false, "Ocurrió un error inesperado en el servidor: " + ex.getMessage());
        return new ResponseEntity<>(apiResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ApiResponse> handleForbiddenException(ForbiddenException ex) {
        ApiResponse apiResponse = new ApiResponse(false, ex.getMessage());
        return new ResponseEntity<>(apiResponse, HttpStatus.FORBIDDEN);
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\exception\ResourceNotFoundException.java
package tutorgo.com.exception;
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\mapper\DisponibilidadMapper.java
package tutorgo.com.mapper;
import org.springframework.stereotype.Component;
import tutorgo.com.dto.response.DisponibilidadResponse;
import tutorgo.com.model.Disponibilidad;
import java.util.List;
import java.util.stream.Collectors;
@Component
public class DisponibilidadMapper {
    public DisponibilidadResponse toDisponibilidadResponse(Disponibilidad disponibilidad) {
        if (disponibilidad == null) {
            return null;
        }
        DisponibilidadResponse response = new DisponibilidadResponse();
        response.setId(disponibilidad.getId());
        if (disponibilidad.getTutor() != null) {
            response.setTutorId(disponibilidad.getTutor().getId());
        }
        response.setFecha(disponibilidad.getFecha());
        response.setHoraInicial(disponibilidad.getHoraInicial());
        response.setHoraFinal(disponibilidad.getHoraFinal());
        return response;
    }
    public List<DisponibilidadResponse> toDisponibilidadResponseList(List<Disponibilidad> disponibilidades) {
        if (disponibilidades == null) {
            return List.of();
        }
        return disponibilidades.stream()
                .map(this::toDisponibilidadResponse)
                .collect(Collectors.toList());
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\mapper\EnlaceSesionMapper.java
package tutorgo.com.mapper;
import org.springframework.stereotype.Component;
import tutorgo.com.dto.request.EnlaceSesionRequestDTO;
import tutorgo.com.dto.response.EnlaceSesionResponseDTO;
import tutorgo.com.model.EnlaceSesion;
import tutorgo.com.model.Sesion;
@Component
public class EnlaceSesionMapper {
    public  EnlaceSesion toEntity(EnlaceSesionRequestDTO dto, Sesion sesion) {
        EnlaceSesion enlace = new EnlaceSesion();
        enlace.setNombre(dto.getNombre());
        enlace.setEnlace(dto.getEnlace());
        enlace.setSesion(sesion);
        return enlace;
    }
    public EnlaceSesionResponseDTO toDTO(EnlaceSesion entity) {
        EnlaceSesionResponseDTO dto = new EnlaceSesionResponseDTO();
        dto.setId(entity.getId());
        dto.setNombre(entity.getNombre());
        dto.setEnlace(entity.getEnlace());
        return dto;
    }
    public EnlaceSesionResponseDTO toResponseDTO(EnlaceSesion enlace) {
        EnlaceSesionResponseDTO dto = new EnlaceSesionResponseDTO();
        dto.setId(enlace.getId());
        dto.setNombre(enlace.getNombre());
        dto.setEnlace(enlace.getEnlace());
        return dto;
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\mapper\PagoMapper.java
package tutorgo.com.mapper;
import org.springframework.stereotype.Component;
import tutorgo.com.dto.response.PagoResponse;
import tutorgo.com.model.Pago;
@Component
public class PagoMapper {
    public PagoResponse toPagoResponse(Pago pago) {
        if (pago == null) {
            return null;
        }
        PagoResponse response = new PagoResponse();
        response.setId(pago.getId());
        response.setMonto(pago.getMonto());
        response.setComisionPlataforma(pago.getComisionPlataforma());
        response.setMetodoPago(pago.getMetodoPago());
        response.setTipoEstado(pago.getTipoEstado());
        if (pago.getTutor() != null) {
            response.setTutorId(pago.getTutor().getId());
            if (pago.getTutor().getUser() != null) {
                response.setNombreTutor(pago.getTutor().getUser().getNombre());
            }
        }
        if (pago.getEstudiante() != null) {
            response.setEstudianteId(pago.getEstudiante().getId());
            if (pago.getEstudiante().getUser() != null) {
                response.setNombreEstudiante(pago.getEstudiante().getUser().getNombre());
            }
        }
        return response;
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\mapper\ResenaMapper.java
package tutorgo.com.mapper;
import org.springframework.stereotype.Component;
import tutorgo.com.dto.request.ResenaRequestDTO;
import tutorgo.com.dto.response.ResenaResponseDTO;
import tutorgo.com.model.Resena;
@Component
public class ResenaMapper {
    public Resena toEntity(ResenaRequestDTO dto) {
        Resena resena = new Resena();
        resena.setCalificacion(dto.getCalificacion());
        resena.setComentario(dto.getComentario());
        return resena;
    }
    public ResenaResponseDTO toDTO(Resena resena) {
        ResenaResponseDTO dto = new ResenaResponseDTO();
        dto.setId(resena.getId());
        dto.setCalificacion(resena.getCalificacion());
        dto.setComentario(resena.getComentario());
        return dto;
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\mapper\SesionMapper.java
package tutorgo.com.mapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import tutorgo.com.dto.response.SesionResponse;
import tutorgo.com.model.Sesion;
import tutorgo.com.model.User;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
@Component
@RequiredArgsConstructor
public class SesionMapper {
    private final EnlaceSesionMapper enlaceSesionMapper;
    public SesionResponse toSesionResponse(Sesion sesion) {
        if (sesion == null) {
            return null;
        }
        SesionResponse response = new SesionResponse();
        response.setId(sesion.getId());
        if (sesion.getTutor() != null) {
            response.setTutorId(sesion.getTutor().getId());
            User tutorUser = sesion.getTutor().getUser();
            if (tutorUser != null) {
                response.setNombreTutor(tutorUser.getNombre());
            }
        }
        if (sesion.getEstudiante() != null) {
            response.setEstudianteId(sesion.getEstudiante().getId());
            User estudianteUser = sesion.getEstudiante().getUser();
            if (estudianteUser != null) {
                response.setNombreEstudiante(estudianteUser.getNombre());
            }
        }
        response.setFecha(sesion.getFecha());
        if (sesion.getEnlaces() != null && !sesion.getEnlaces().isEmpty()) {
            response.setEnlaces(
                    sesion.getEnlaces().stream()
                            .map(enlaceSesionMapper::toDTO) // Reutilizamos el EnlaceSesionMapper
                            .collect(Collectors.toList())
            );
        } else {
            response.setEnlaces(Collections.emptyList()); // Asegurarse de que no sea nulo
        }
        response.setHoraInicial(sesion.getHoraInicial());
        response.setHoraFinal(sesion.getHoraFinal());
        response.setTipoEstado(sesion.getTipoEstado());
        response.setFueCalificada(sesion.getResena() != null);
        return response;
    }
    public List<SesionResponse> toSesionResponseList(List<Sesion> sesiones) {
        if (sesiones == null) {
            return Collections.emptyList();
        }
        return sesiones.stream()
                .map(this::toSesionResponse)
                .collect(Collectors.toList());
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\mapper\SesionProgramadaMapper.java
package tutorgo.com.mapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import tutorgo.com.dto.response.EnlaceSesionResponseDTO;
import tutorgo.com.dto.response.SesionProgramadaResponseDTO;
import tutorgo.com.model.EnlaceSesion;
import tutorgo.com.model.Sesion;
import java.util.List;
import java.util.stream.Collectors;
@Component
@RequiredArgsConstructor
public class SesionProgramadaMapper {
    private final EnlaceSesionMapper enlaceSesionMapper;
    public SesionProgramadaResponseDTO toResponseDTO(Sesion sesion) {
        SesionProgramadaResponseDTO dto = new SesionProgramadaResponseDTO();
        dto.setSesionId(sesion.getId());
        List<EnlaceSesion> enlaces = sesion.getEnlaces();
        if (enlaces != null && !enlaces.isEmpty()) {
            List<EnlaceSesionResponseDTO> enlacesDTO = enlaces.stream()
                    .map(enlace -> enlaceSesionMapper.toResponseDTO(enlace)) // lambda explícita
                    .collect(Collectors.toList());
            dto.setEnlaces(enlacesDTO);
            dto.setEnlaceDisponible(true);
            dto.setMensaje("Redirigiendo al enlace de la tutoría...");
        } else {
            dto.setEnlaceDisponible(false);
            dto.setMensaje("El tutor aún no ha compartido el enlace de la sesión");
            dto.setEnlaces(List.of()); // Devolver lista vacía
        }
        return dto;
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\mapper\TutorMapper.java
package tutorgo.com.mapper;
import org.springframework.stereotype.Component;
import tutorgo.com.dto.response.PagedResponse;
import tutorgo.com.dto.response.TutorSummaryResponse;
import tutorgo.com.model.Tutor;
import tutorgo.com.model.User;
import java.util.List;
import java.util.stream.Collectors;
@Component
public class TutorMapper {
    public TutorSummaryResponse tutorToTutorSummaryResponse(Tutor tutor) {
        if (tutor == null) {
            return null;
        }
        TutorSummaryResponse response = new TutorSummaryResponse();
        response.setTutorId(tutor.getId());
        response.setRubro(tutor.getRubro());
        response.setEstrellasPromedio(tutor.getEstrellasPromedio());
        User user = tutor.getUser();
        if (user != null) {
            response.setNombreUsuario(user.getNombre());
            response.setFotoUrlUsuario(user.getFotoUrl());
        } else {
            response.setNombreUsuario("Nombre no disponible");
        }
        response.setTarifaHora(tutor.getTarifaHora());
        return response;
    }
    public List<TutorSummaryResponse> tutorsToTutorSummaryResponseList(List<Tutor> tutores) {
        if (tutores == null) {
            return List.of();
        }
        return tutores.stream()
                .map(this::tutorToTutorSummaryResponse)
                .collect(Collectors.toList());
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\mapper\UserMapper.java
package tutorgo.com.mapper;
import tutorgo.com.dto.response.StudentProfileResponse;
import tutorgo.com.dto.response.TutorProfileResponse;
import tutorgo.com.dto.response.UserResponse;
import tutorgo.com.model.Estudiante;
import tutorgo.com.model.Tutor;
import tutorgo.com.model.User;
import org.springframework.stereotype.Component;
@Component
public class UserMapper {
    public UserResponse userToUserResponse(User user) {
        if (user == null) {
            return null;
        }
        UserResponse userResponse = new UserResponse();
        userResponse.setId(user.getId());
        userResponse.setNombre(user.getNombre());
        userResponse.setEmail(user.getEmail());
        userResponse.setFotoUrl(user.getFotoUrl());
        if (user.getRole() != null) {
            userResponse.setRol(user.getRole().getNombre());
        } else {
            userResponse.setRol(null); // O manejar como un error si el rol es siempre esperado
        }
        userResponse.setTutorProfile(tutorToTutorProfileResponse(user.getTutorProfile()));
        userResponse.setStudentProfile(estudianteToStudentProfileResponse(user.getStudentProfile()));
        return userResponse;
    }
    public TutorProfileResponse tutorToTutorProfileResponse(Tutor tutor) {
        if (tutor == null) {
            return null;
        }
        TutorProfileResponse dto = new TutorProfileResponse();
        dto.setId(tutor.getId());
        dto.setTarifaHora(tutor.getTarifaHora());
        dto.setRubro(tutor.getRubro());
        dto.setBio(tutor.getBio());
        dto.setEstrellasPromedio(tutor.getEstrellasPromedio());
        return dto;
    }
    public StudentProfileResponse estudianteToStudentProfileResponse(Estudiante estudiante) {
        if (estudiante == null) {
            return null;
        }
        StudentProfileResponse dto = new StudentProfileResponse();
        dto.setId(estudiante.getId());
        dto.setCentroEstudio(estudiante.getCentroEstudio());
        return dto;
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\model\Disponibilidad.java
package tutorgo.com.model;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDate;
import java.time.LocalDateTime;
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "disponibilidades")
public class Disponibilidad {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tutor_id", nullable = false)
    private Tutor tutor;
    @Column(nullable = false)
    private LocalDate fecha;
    @Column(name = "hora_inicial", nullable = false)
    private LocalDateTime horaInicial;
    @Column(name = "hora_final", nullable = false)
    private LocalDateTime horaFinal;
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\model\EnlaceSesion.java
package tutorgo.com.model;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
@Data
@NoArgsConstructor
@Entity
@Table(name = "enlaces_sesiones",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = {"sesion_id", "enlace"}),
                @UniqueConstraint(columnNames = {"sesion_id", "nombre"})
        }
)
public class EnlaceSesion {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "sesion_id", nullable = false)
    private Sesion sesion;
    @Column(length = 150, nullable = false)
    private String nombre;
    @Column(length = 500, nullable = false)
    private String enlace;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\model\Estudiante.java
package tutorgo.com.model;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "estudiantes")
public class Estudiante {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @OneToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "usuario_id", nullable = false, unique = true, referencedColumnName = "id")
    private User user;
    @Column(name = "centro_estudio", length = 255, nullable = false)
    private String centroEstudio;
    @OneToMany(mappedBy = "estudiante", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore
    private List<Sesion> sesionesComoEstudiante = new ArrayList<>();
    @OneToMany(mappedBy = "estudiante", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore
    private List<Pago> pagosRealizados = new ArrayList<>();
    @OneToMany(mappedBy = "estudiante", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore
    private List<NotificacionEstudiante> notificacionesEstudiante = new ArrayList<>();
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Estudiante that = (Estudiante) o;
        return Objects.equals(id, that.id);
    }
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\model\NotificacionEstudiante.java
package tutorgo.com.model;
import tutorgo.com.enums.TipoNotificacionEstEnum;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;
import java.time.LocalDateTime;
@Data
@NoArgsConstructor
@Entity
@Table(name = "notificacion_estudiantes")
public class NotificacionEstudiante {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "estudiante_id", nullable = false)
    private Estudiante estudiante;
    @Column(length = 255, nullable = false)
    private String titulo;
    @Enumerated(EnumType.STRING)
    @Column(name = "tipo", nullable = false, columnDefinition = "tipo_notificacion_est_enum")
    @JdbcTypeCode(SqlTypes.NAMED_ENUM)
    private TipoNotificacionEstEnum tipo;
    @Column(columnDefinition = "TEXT", nullable = false)
    private String texto;
    @Column(name = "fecha_creacion", nullable = false)
    private LocalDateTime fechaCreacion;
    @PrePersist
    protected void onCreate() {
        this.fechaCreacion = LocalDateTime.now();
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\model\NotificacionTutor.java
package tutorgo.com.model;
import tutorgo.com.enums.TipoNotificacionTutorEnum;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;
import java.time.LocalDateTime;
@Data
@NoArgsConstructor
@Entity
@Table(name = "notificacion_tutores")
public class NotificacionTutor {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tutor_id", nullable = false)
    private Tutor tutor;
    @Column(length = 255, nullable = false)
    private String titulo;
    @Enumerated(EnumType.STRING)
    @Column(name = "tipo", nullable = false, columnDefinition = "tipo_notificacion_tutor_enum")
    @JdbcTypeCode(SqlTypes.NAMED_ENUM)
    private TipoNotificacionTutorEnum tipo;
    @Column(columnDefinition = "TEXT", nullable = false)
    private String texto;
    @Column(name = "fecha_creacion", nullable = false)
    private LocalDateTime fechaCreacion;
    @PrePersist
    protected void onCreate() {
        this.fechaCreacion = LocalDateTime.now();
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\model\Pago.java
package tutorgo.com.model;
import lombok.AllArgsConstructor;
import lombok.Builder;
import tutorgo.com.enums.EstadoPagoEnum;
import tutorgo.com.enums.MetodoPagoEnum;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "pagos")
public class Pago {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tutor_id", nullable = false)
    private Tutor tutor;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "estudiante_id", nullable = false)
    private Estudiante estudiante;
    @Column(nullable = false)
    private BigDecimal monto;
    @Column(name = "comision_plataforma", nullable = false)
    private BigDecimal comisionPlataforma;
    @Enumerated(EnumType.STRING)
    @Column(name = "metodo_pago", nullable = false, columnDefinition = "metodo_pago_enum")
    private MetodoPagoEnum metodoPago;
    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_estado", nullable = false, columnDefinition = "estado_pago_enum")
    private EstadoPagoEnum tipoEstado;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\model\Resena.java
package tutorgo.com.model;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
@Data
@NoArgsConstructor
@Entity
@Table(name = "resenas")
public class Resena {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "sesion_id", nullable = false, unique = true)
    private Sesion sesion;
    @Column(nullable = false) // CHECK (calificacion BETWEEN 1 AND 5) se maneja a nivel BD
    private Integer calificacion;
    @Column(columnDefinition = "TEXT")
    private String comentario;
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\model\Role.java
package tutorgo.com.model;
import tutorgo.com.enums.RoleName;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    @Enumerated(EnumType.STRING)
    @Column(length = 150, nullable = false, unique = true)
    private RoleName nombre;
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\model\Sesion.java
package tutorgo.com.model;
import lombok.AllArgsConstructor;
import lombok.Builder;
import tutorgo.com.enums.EstadoSesionEnum;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
@Data
@NoArgsConstructor@AllArgsConstructor
@Builder
@Entity
@Table(name = "sesiones")
public class Sesion {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "tutor_id", nullable = false)
    private Tutor tutor;
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "estudiante_id", nullable = false)
    private Estudiante estudiante;
    @Column(nullable = false)
    private LocalDate fecha;
    @Column(name = "hora_inicial", nullable = false)
    private LocalDateTime horaInicial;
    @Column(name = "hora_final", nullable = false)
    private LocalDateTime horaFinal;
    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_estado", nullable = false, columnDefinition = "estado_sesion_enum")
    private EstadoSesionEnum tipoEstado;
    @OneToMany(mappedBy = "sesion", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<EnlaceSesion> enlaces = new ArrayList<>();
    @OneToOne(mappedBy = "sesion", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
    private Resena resena;
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\model\Tutor.java
package tutorgo.com.model;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import com.fasterxml.jackson.annotation.JsonIgnore;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "tutores")
public class Tutor {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @OneToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "usuario_id", nullable = false, unique = true, referencedColumnName = "id")
    private User user;
    @Column(name = "tarifa_hora", nullable = false)
    private Integer tarifaHora;
    @Column(length = 150, nullable = false, columnDefinition = "TEXT")
    private String rubro;
    @Column(columnDefinition = "TEXT")
    private String bio;
    @Column(name = "estrellas_promedio", nullable = false)
    private Float estrellasPromedio = 0.0f; // Valor por defecto
    @OneToMany(mappedBy = "tutor", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore
    private List<Disponibilidad> disponibilidades = new ArrayList<>();
    @OneToMany(mappedBy = "tutor", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore
    private List<Sesion> sesionesComoTutor = new ArrayList<>();
    @OneToMany(mappedBy = "tutor", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore
    private List<Pago> pagosRecibidos = new ArrayList<>();
    @OneToMany(mappedBy = "tutor", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore
    private List<NotificacionTutor> notificacionesTutor = new ArrayList<>();
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Tutor tutor = (Tutor) o;
        return Objects.equals(id, tutor.id);
    }
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\model\User.java
package tutorgo.com.model;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import com.fasterxml.jackson.annotation.JsonIgnore;
import java.util.Objects;
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "usuarios", uniqueConstraints = {
        @UniqueConstraint(columnNames = "email")
})
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(length = 150, nullable = false, columnDefinition = "TEXT")
    private String nombre;
    @Column(length = 150, nullable = false, unique = true)
    private String email;
    @Column(name = "password_hash", length = 150, nullable = false, columnDefinition = "TEXT")
    private String password;
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "rol_id", nullable = false)
    private Role role;
    @Column(name = "foto_url", length = 255, columnDefinition = "TEXT")
    private String fotoUrl;
    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY, optional = true)
    @JsonIgnore
    private Tutor tutorProfile;
    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY, optional = true)
    @JsonIgnore
    private Estudiante studentProfile;
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return Objects.equals(id, user.id);
    }
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\repository\DisponibilidadRepository.java
package tutorgo.com.repository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import tutorgo.com.model.Disponibilidad;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import tutorgo.com.model.Tutor;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
@Repository
public interface DisponibilidadRepository extends JpaRepository<Disponibilidad, Long> {
    List<Disponibilidad> findByTutorAndFecha(Tutor tutor, LocalDate fecha);
    List<Disponibilidad> findByTutorOrderByFechaAscHoraInicialAsc(Tutor tutor);
    @Query("SELECT d FROM Disponibilidad d WHERE d.tutor.id = :tutorId AND d.fecha = :fecha " +
            "AND d.horaInicial < :horaFinalNueva AND d.horaFinal > :horaInicialNueva")
    List<Disponibilidad> findDisponibilidadesSolapadas(@Param("tutorId") Long tutorId,
                                                       @Param("fecha") LocalDate fecha,
                                                       @Param("horaInicialNueva") LocalDateTime horaInicialNueva,
                                                       @Param("horaFinalNueva") LocalDateTime horaFinalNueva);
    @Query("SELECT d FROM Disponibilidad d WHERE d.tutor.id = :tutorId AND d.id <> :disponibilidadIdExcluir AND d.fecha = :fecha " +
            "AND d.horaInicial < :horaFinalNueva AND d.horaFinal > :horaInicialNueva")
    List<Disponibilidad> findDisponibilidadesSolapadasExcluyendoActual(@Param("tutorId") Long tutorId,
                                                                       @Param("fecha") LocalDate fecha,
                                                                       @Param("horaInicialNueva") LocalDateTime horaInicialNueva,
                                                                       @Param("horaFinalNueva") LocalDateTime horaFinalNueva,
                                                                       @Param("disponibilidadIdExcluir") Long disponibilidadIdExcluir);
    @Query("SELECT d FROM Disponibilidad d WHERE d.tutor.id = :tutorId AND d.fecha = :fecha " +
            "AND d.horaInicial <= :horaInicioSesion AND d.horaFinal >= :horaFinSesion")
    List<Disponibilidad> findDisponibilidadQueEnvuelveElSlot(@Param("tutorId") Long tutorId,
                                                             @Param("fecha") LocalDate fecha,
                                                             @Param("horaInicioSesion") LocalDateTime horaInicioSesion,
                                                             @Param("horaFinSesion") LocalDateTime horaFinSesion);
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\repository\EnlaceSesionRepository.java
package tutorgo.com.repository;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import tutorgo.com.model.EnlaceSesion;
import java.util.List;
@Repository
public interface EnlaceSesionRepository extends JpaRepository<EnlaceSesion, Long> {
    List<EnlaceSesion> findBySesionId(Long sesionId);
    long countBySesionId(Long sesionId);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\repository\EstudianteRepository.java
package tutorgo.com.repository;
import tutorgo.com.model.Estudiante;
import tutorgo.com.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;
@Repository
public interface EstudianteRepository extends JpaRepository<Estudiante, Long> {
    Optional<Estudiante> findByUser(User user);
    Optional<Estudiante> findByUserId(Long userId);
    Optional<Estudiante> findByUserEmail(String email);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\repository\NotificacionEstudianteRepository.java
package tutorgo.com.repository;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import tutorgo.com.model.Estudiante;
import tutorgo.com.model.NotificacionEstudiante;
import java.util.List; // Importar
@Repository
public interface NotificacionEstudianteRepository extends JpaRepository<NotificacionEstudiante, Long> {
    List<NotificacionEstudiante> findByEstudianteOrderByFechaCreacionDesc(Estudiante estudiante);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\repository\NotificacionTutorRepository.java
package tutorgo.com.repository;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import tutorgo.com.model.NotificacionTutor;
import tutorgo.com.model.Tutor;
import java.util.List;
@Repository
public interface NotificacionTutorRepository extends JpaRepository<NotificacionTutor, Long> {
    List<NotificacionTutor> findByTutorOrderByFechaCreacionDesc(Tutor tutor);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\repository\PagoRepository.java
package tutorgo.com.repository;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import tutorgo.com.model.Pago;
import java.util.List;
@Repository
public interface PagoRepository extends JpaRepository<Pago, Long> {
    @Query("SELECT p FROM Pago p " +
            "JOIN FETCH p.tutor t " +
            "JOIN FETCH t.user " +
            "JOIN FETCH p.estudiante e " +
            "JOIN FETCH e.user " +
            "WHERE e.id = :estudianteId ORDER BY p.id DESC")
    List<Pago> findByEstudianteIdWithDetails(@Param("estudianteId") Long estudianteId);
    @Query("SELECT p FROM Pago p " +
            "JOIN FETCH p.tutor t " +
            "JOIN FETCH t.user " +
            "JOIN FETCH p.estudiante e " +
            "JOIN FETCH e.user " +
            "WHERE t.id = :tutorId ORDER BY p.id DESC")
    List<Pago> findByTutorIdWithDetails(@Param("tutorId") Long tutorId);
    List<Pago> findByEstudianteIdOrderByIdDesc(Long estudianteId);
    List<Pago> findByTutorIdOrderByIdDesc(Long tutorId);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\repository\ResenaRepository.java
package tutorgo.com.repository;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import tutorgo.com.model.Resena;
import java.util.Optional;
@Repository
public interface ResenaRepository extends JpaRepository<Resena, Long> {
    Optional<Resena> findBySesionId(Long sesionId);
    boolean existsBySesionId(Long sesionId);
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\repository\RoleRepository.java
package tutorgo.com.repository;
import tutorgo.com.enums.RoleName;
import tutorgo.com.model.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;
@Repository
public interface RoleRepository extends JpaRepository<Role, Integer> {
    Optional<Role> findByNombre(RoleName nombre);
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\repository\SesionRepository.java
package tutorgo.com.repository;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import tutorgo.com.enums.EstadoSesionEnum;
import tutorgo.com.model.Estudiante; // Si usas findByEstudiante...
import tutorgo.com.model.Sesion;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
@Repository
public interface SesionRepository extends JpaRepository<Sesion, Long> {
    List<Sesion> findByHoraInicialBetween(LocalDateTime desde, LocalDateTime hasta);
    @Query("SELECT s FROM Sesion s WHERE s.tutor.id = :tutorId AND s.fecha = :fecha " +
            "AND s.horaInicial < :horaFinalReserva AND s.horaFinal > :horaInicialReserva " +
            "AND s.tipoEstado IN (tutorgo.com.enums.EstadoSesionEnum.CONFIRMADO, tutorgo.com.enums.EstadoSesionEnum.PENDIENTE)")
    List<Sesion> findSesionesSolapadasParaTutor(@Param("tutorId") Long tutorId,
                                                @Param("fecha") LocalDate fecha,
                                                @Param("horaInicialReserva") LocalDateTime horaInicialReserva,
                                                @Param("horaFinalReserva") LocalDateTime horaFinalReserva);
    List<Sesion> findByEstudianteIdOrderByFechaAscHoraInicialAsc(Long estudianteId);
    @Query("SELECT s FROM Sesion s WHERE s.estudiante.id = :estudianteId AND s.fecha = :fecha " +
            "AND s.horaInicial < :horaFinalReserva AND s.horaFinal > :horaInicialReserva " +
            "AND s.tipoEstado IN (tutorgo.com.enums.EstadoSesionEnum.CONFIRMADO, tutorgo.com.enums.EstadoSesionEnum.PENDIENTE)")
    List<Sesion> findSesionesSolapadasParaEstudiante(@Param("estudianteId") Long estudianteId,
                                                     @Param("fecha") LocalDate fecha,
                                                     @Param("horaInicialReserva") LocalDateTime horaInicialReserva,
                                                     @Param("horaFinalReserva") LocalDateTime horaFinalReserva);
    @Query("SELECT COUNT(s) FROM Sesion s WHERE s.tutor.id = :tutorId AND s.fecha = :fecha " +
            "AND s.horaInicial < :horaFinalDisp AND s.horaFinal > :horaInicialDisp " +
            "AND s.tipoEstado IN (tutorgo.com.enums.EstadoSesionEnum.PENDIENTE, tutorgo.com.enums.EstadoSesionEnum.CONFIRMADO)")
    long countSesionesActivasEnRango(@Param("tutorId") Long tutorId,
                                     @Param("fecha") LocalDate fecha,
                                     @Param("horaInicialDisp") LocalDateTime horaInicialDisp,
                                     @Param("horaFinalDisp") LocalDateTime horaFinalDisp);
    List<Sesion> findByTipoEstadoAndHoraInicialBetween( // Nombre del método cambiado
                                                        EstadoSesionEnum tipoEstado,
                                                        LocalDateTime horaInicialDesde,
                                                        LocalDateTime horaInicialHasta
    );
    List<Sesion> findByEstudiante_User_EmailOrderByFechaAscHoraInicialAsc(String email);
    List<Sesion> findByTutor_User_EmailOrderByFechaAscHoraInicialAsc(String email);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\repository\TutorRepository.java
package tutorgo.com.repository;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import tutorgo.com.model.Tutor;
import tutorgo.com.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;
@Repository
public interface TutorRepository extends JpaRepository<Tutor, Long> {
    Optional<Tutor> findByUser(User user);
    Optional<Tutor> findByUserId(Long userId);
    @Query(value = "SELECT t FROM Tutor t JOIN FETCH t.user u",
            countQuery = "SELECT COUNT(t) FROM Tutor t")
    Page<Tutor> findAllWithUser(Pageable pageable);
    @Query("SELECT t FROM Tutor t JOIN t.user u " +
            "WHERE LOWER(u.nombre) LIKE LOWER(CONCAT('%', :query, '%')) OR " +
            "LOWER(t.rubro) LIKE LOWER(CONCAT('%', :query, '%'))")
    Page<Tutor> searchByQuery(@Param("query") String query, Pageable pageable);
    @Query("SELECT t FROM Tutor t JOIN t.user u WHERE " +
            "(:query IS NULL OR LOWER(u.nombre) LIKE LOWER(CONCAT('%', :query, '%')) OR LOWER(t.rubro) LIKE LOWER(CONCAT('%', :query, '%'))) " +
            "AND (:maxPrecio IS NULL OR t.tarifaHora <= :maxPrecio) " +
            "AND (:puntuacion IS NULL OR t.estrellasPromedio >= :puntuacion)")
    Page<Tutor> searchWithFilters(
            @Param("query") String query,
            @Param("maxPrecio") Integer maxPrecio,
            @Param("puntuacion") Float puntuacion,
            Pageable pageable
    );
    @Query("SELECT t FROM Tutor t JOIN t.user u WHERE " +
            "LOWER(u.nombre) LIKE LOWER(CONCAT('%', :query, '%')) OR " +
            "LOWER(t.rubro) LIKE LOWER(CONCAT('%', :query, '%'))")
    Page<Tutor> searchByNameOrRubro(@Param("query") String query, Pageable pageable);
    @Query("SELECT t FROM Tutor t JOIN FETCH t.user u WHERE " + // JOIN FETCH para optimizar
            "(:maxPrecio IS NULL OR t.tarifaHora <= :maxPrecio) " +
            "AND (:puntuacion IS NULL OR t.estrellasPromedio >= :puntuacion)")
    List<Tutor> findWithNumericFilters(
            @Param("maxPrecio") Integer maxPrecio,
            @Param("puntuacion") Float puntuacion
    );
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\repository\UserRepository.java
package tutorgo.com.repository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import tutorgo.com.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    Boolean existsByEmail(String email);
    @Query("SELECT u FROM User u " +
            "LEFT JOIN FETCH u.role " +
            "LEFT JOIN FETCH u.studentProfile " +
            "LEFT JOIN FETCH u.tutorProfile " +
            "WHERE u.email = :email")
    Optional<User> findByEmailWithProfiles(@Param("email") String email);
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\scheduler\NotificacionScheduler.java
package tutorgo.com.scheduler;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import tutorgo.com.enums.EstadoSesionEnum;
import tutorgo.com.model.Sesion;
import tutorgo.com.repository.SesionRepository;
import tutorgo.com.service.NotificacionSenderService; // ***** CAMBIO IMPORTANTE AQUÍ *****
import java.time.LocalDateTime;
import java.util.List;
@Component
@RequiredArgsConstructor
public class NotificacionScheduler {
    private static final Logger log = LoggerFactory.getLogger(NotificacionScheduler.class);
    private final SesionRepository sesionRepository;
    private final NotificacionSenderService notificacionSenderService;
    @Scheduled(cron = "0 * * * * *")
    public void enviarRecordatorios24h() {
        log.info("Ejecutando scheduler de recordatorios de 24 horas...");
        LocalDateTime ahora = LocalDateTime.now();
        LocalDateTime inicioRango = ahora.plusHours(23).plusMinutes(59); // Rango de 1 minuto
        LocalDateTime finRango = ahora.plusHours(24).plusMinutes(1);
        List<Sesion> sesionesProximas = sesionRepository.findByTipoEstadoAndHoraInicialBetween(
                EstadoSesionEnum.CONFIRMADO,
                inicioRango,
                finRango
        );
        if (!sesionesProximas.isEmpty()) {
            log.info("Se encontraron {} sesiones próximas para enviar recordatorios.", sesionesProximas.size());
            for (Sesion sesion : sesionesProximas) {
                notificacionSenderService.enviarRecordatorioSesion(sesion);
                log.info("Notificaciones de recordatorio generadas para la sesión ID: {}", sesion.getId());
            }
        }
        log.info("Scheduler de recordatorios finalizado.");
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\security\CustomUserDetails.java
package tutorgo.com.security;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import tutorgo.com.model.User; // Importa tu entidad User
import java.util.Collection;
public class CustomUserDetails implements UserDetails {
    private final User user; // Almacena tu entidad User completa
    private final Collection<? extends GrantedAuthority> authorities;
    public CustomUserDetails(User user, Collection<? extends GrantedAuthority> authorities) {
        this.user = user;
        this.authorities = authorities;
    }
    public Long getId() {
        return user.getId();
    }
    public String getNombreCompleto() { // O como se llame el método en tu entidad User
        return user.getNombre();
    }
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }
    @Override
    public String getPassword() {
        return user.getPassword(); // El hash de la contraseña
    }
    @Override
    public String getUsername() {
        return user.getEmail(); // Usamos email como username
    }
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }
    @Override
    public boolean isEnabled() {
        return true; // O según un campo 'enabled' en tu entidad User
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\security\JwtAuthenticationEntryPoint.java
package tutorgo.com.security;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;
import java.io.IOException;
@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {
    private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationEntryPoint.class);
    @Override
    public void commence(HttpServletRequest request,
                         HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        logger.error("Respondiendo con error no autorizado. Mensaje - {}", authException.getMessage());
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Acceso no autorizado. Necesitas autenticarte para acceder a este recurso.");
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\security\JwtAuthenticationFilter.java
package tutorgo.com.security;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;
import java.io.IOException;
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtTokenProvider tokenProvider;
    private final UserDetailsService userDetailsService;
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);
            if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
                String username = tokenProvider.getUsernameFromJWT(jwt);
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            logger.error("No se pudo establecer la autenticación del usuario en el contexto de seguridad", ex);
        }
        filterChain.doFilter(request, response);
    }
    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\security\JwtTokenProvider.java
package tutorgo.com.security;
import io.jsonwebtoken.*;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import tutorgo.com.model.User;
import org.springframework.stereotype.Component;
import java.security.Key;
import java.util.Date;
import java.util.stream.Collectors;
@Component
public class JwtTokenProvider {
    private static final Logger logger = LoggerFactory.getLogger(JwtTokenProvider.class);
    @Value("${jwt.secret}")
    private String jwtSecret;
    @Value("${jwt.expiration.ms}")
    private int jwtExpirationInMs;
    public String generateToken(Authentication authentication) {
        String username = authentication.getName(); // Email del usuario
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationInMs);
        String roles = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));
        Long userId = null;
        String nombreUsuario = null;
        Object principal = authentication.getPrincipal();
        if (principal instanceof CustomUserDetails) {
            CustomUserDetails customUserDetails = (CustomUserDetails) principal;
            userId = customUserDetails.getId();
            nombreUsuario = customUserDetails.getNombreCompleto();
        } else {
            logger.warn("El principal no es una instancia de CustomUserDetails. No se añadirán userId y nombre al token. Principal es: {}", principal.getClass().getName());
        }
        JwtBuilder builder = Jwts.builder()
                .setSubject(username)
                .claim("roles", roles);
        if (userId != null) {
            builder.claim("userId", userId);
        }
        if (nombreUsuario != null) {
            builder.claim("nombre", nombreUsuario);
        }
        return builder
                .setIssuedAt(new Date())
                .setExpiration(expiryDate)
                .signWith(key(), SignatureAlgorithm.HS512)
                .compact();
    }
    private Key key() {
        return Keys.hmacShaKeyFor(Decoders.BASE64.decode(jwtSecret));
    }
    public String getUsernameFromJWT(String token) {
        Claims claims = Jwts.parserBuilder()
                .setSigningKey(key())
                .build()
                .parseClaimsJws(token)
                .getBody();
        return claims.getSubject();
    }
    public boolean validateToken(String authToken) {
        try {
            Jwts.parserBuilder()
                    .setSigningKey(key())
                    .build()
                    .parseClaimsJws(authToken);
            return true;
        } catch (MalformedJwtException ex) {
            logger.error("Token JWT inválido: {}", ex.getMessage());
        } catch (ExpiredJwtException ex) {
            logger.error("Token JWT expirado: {}", ex.getMessage());
        } catch (UnsupportedJwtException ex) {
            logger.error("Token JWT no soportado: {}", ex.getMessage());
        } catch (IllegalArgumentException ex) {
            logger.error("Las claims del JWT están vacías: {}", ex.getMessage());
        }
        return false;
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\security\SecurityUtil.java
package tutorgo.com.security;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
public class SecurityUtil {
    private SecurityUtil() {} // evita instanciación
    public static String extractUserEmail(Authentication authentication) {
        if (authentication == null || !authentication.isAuthenticated() || "anonymousUser".equals(authentication.getPrincipal())) {
            throw new AccessDeniedException("Usuario no autenticado.");
        }
        Object principal = authentication.getPrincipal();
        if (principal instanceof UserDetails) {
            return ((UserDetails) principal).getUsername();
        } else if (principal != null) {
            return principal.toString();
        }
        throw new IllegalStateException("No se pudo determinar el email del usuario autenticado desde el principal.");
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\security\UserDetailsServiceImpl.java

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\AuthService.java
package tutorgo.com.service;
import tutorgo.com.dto.request.LoginRequest;
import tutorgo.com.dto.response.JwtAuthenticationResponse;
public interface AuthService {
    JwtAuthenticationResponse loginUser(LoginRequest loginRequest);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\AuthServiceImpl.java
package tutorgo.com.service;
import tutorgo.com.dto.request.LoginRequest;
import tutorgo.com.dto.response.JwtAuthenticationResponse;
import tutorgo.com.dto.response.UserResponse;
import tutorgo.com.exception.ResourceNotFoundException; // Para HU2 Escenario 3
import tutorgo.com.mapper.UserMapper;
import tutorgo.com.model.User;
import tutorgo.com.repository.UserRepository;
import tutorgo.com.security.JwtTokenProvider;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException; // Para HU2 Escenario 2
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
@Service
@RequiredArgsConstructor
public class AuthServiceImpl implements AuthService {
    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;
    private final UserRepository userRepository;
    private final UserMapper userMapper;
    @Override
    public JwtAuthenticationResponse loginUser(LoginRequest loginRequest) {
        User user = userRepository.findByEmail(loginRequest.getEmail())
                .orElseThrow(() -> new ResourceNotFoundException("Correo no registrado. Regístrese."));
        Authentication authentication;
        try {
            authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getEmail(),
                            loginRequest.getPassword()
                    )
            );
        } catch (BadCredentialsException e) {
            throw new BadCredentialsException("Credenciales inválidas. Pruebe de nuevo.");
        }
        SecurityContextHolder.getContext().setAuthentication(authentication);
        String jwt = jwtTokenProvider.generateToken(authentication);
        UserResponse userDto = userMapper.userToUserResponse(user);
        return new JwtAuthenticationResponse(jwt, userDto);
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\DisponibilidadService.java
package tutorgo.com.service;
import tutorgo.com.dto.request.DisponibilidadRequest;
import tutorgo.com.dto.response.DisponibilidadResponse;
import java.util.List;
public interface DisponibilidadService {
    DisponibilidadResponse addDisponibilidad(String tutorEmail, DisponibilidadRequest request);
    DisponibilidadResponse updateDisponibilidad(String tutorEmail, Long disponibilidadId, DisponibilidadRequest request);
    List<DisponibilidadResponse> getDisponibilidadesByTutor(String tutorEmail);
    void deleteDisponibilidad(String tutorEmail, Long disponibilidadId);
    List<DisponibilidadResponse> getDisponibilidadesByTutorId(Long tutorId);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\DisponibilidadServiceImpl.java
package tutorgo.com.service;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tutorgo.com.dto.request.DisponibilidadRequest;
import tutorgo.com.dto.response.DisponibilidadResponse;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.exception.ForbiddenException; // Nueva excepción para permisos
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.mapper.DisponibilidadMapper;
import tutorgo.com.model.Disponibilidad;
import tutorgo.com.model.Tutor;
import tutorgo.com.model.User;
import tutorgo.com.repository.DisponibilidadRepository;
import tutorgo.com.repository.TutorRepository;
import tutorgo.com.repository.UserRepository;
import tutorgo.com.repository.SesionRepository; // Para verificar si hay sesiones reservadas
import java.time.LocalDateTime;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
@Service
@RequiredArgsConstructor
public class DisponibilidadServiceImpl implements DisponibilidadService {
    private final UserRepository userRepository;
    private final TutorRepository tutorRepository;
    private final DisponibilidadRepository disponibilidadRepository;
    private final SesionRepository sesionRepository; // Para validaciones al actualizar/borrar
    private final DisponibilidadMapper disponibilidadMapper;
    @Override
    @Transactional
    public DisponibilidadResponse addDisponibilidad(String tutorEmail, DisponibilidadRequest request) {
        User userTutor = userRepository.findByEmail(tutorEmail)
                .orElseThrow(() -> new ResourceNotFoundException("Usuario tutor no encontrado: " + tutorEmail));
        Tutor tutor = tutorRepository.findByUser(userTutor)
                .orElseThrow(() -> new ResourceNotFoundException("Perfil de tutor no encontrado para el usuario: " + tutorEmail));
        LocalDateTime horaInicialDateTime = LocalDateTime.of(request.getFecha(), request.getHoraInicio());
        LocalDateTime horaFinalDateTime = LocalDateTime.of(request.getFecha(), request.getHoraFinal());
        if (horaFinalDateTime.isBefore(horaInicialDateTime) || horaFinalDateTime.equals(horaInicialDateTime)) {
            throw new BadRequestException("La hora de finalización debe ser posterior a la hora de inicio.");
        }
        List<Disponibilidad> disponibilidadesSolapadas = disponibilidadRepository
                .findDisponibilidadesSolapadas(tutor.getId(), request.getFecha(), horaInicialDateTime, horaFinalDateTime);
        if (!disponibilidadesSolapadas.isEmpty()) {
            throw new BadRequestException("La nueva disponibilidad se solapa con una existente.");
        }
        Disponibilidad nuevaDisponibilidad = new Disponibilidad();
        nuevaDisponibilidad.setTutor(tutor);
        nuevaDisponibilidad.setFecha(request.getFecha());
        nuevaDisponibilidad.setHoraInicial(horaInicialDateTime);
        nuevaDisponibilidad.setHoraFinal(horaFinalDateTime);
        Disponibilidad guardada = disponibilidadRepository.save(nuevaDisponibilidad);
        return disponibilidadMapper.toDisponibilidadResponse(guardada);
    }
    @Override
    @Transactional(readOnly = true)
    public List<DisponibilidadResponse> getDisponibilidadesByTutor(String tutorEmail) {
        User userTutor = userRepository.findByEmail(tutorEmail)
                .orElseThrow(() -> new ResourceNotFoundException("Usuario tutor no encontrado: " + tutorEmail));
        Tutor tutor = tutorRepository.findByUser(userTutor)
                .orElseThrow(() -> new ResourceNotFoundException("Perfil de tutor no encontrado para el usuario: " + tutorEmail));
        List<Disponibilidad> disponibilidades = disponibilidadRepository.findByTutorOrderByFechaAscHoraInicialAsc(tutor);
        return disponibilidadMapper.toDisponibilidadResponseList(disponibilidades);
    }
    @Override
    @Transactional
    public DisponibilidadResponse updateDisponibilidad(String tutorEmail, Long disponibilidadId, DisponibilidadRequest request) {
        User userTutor = userRepository.findByEmail(tutorEmail)
                .orElseThrow(() -> new ResourceNotFoundException("Usuario tutor no encontrado: " + tutorEmail));
        Tutor tutor = tutorRepository.findByUser(userTutor)
                .orElseThrow(() -> new ResourceNotFoundException("Perfil de tutor no encontrado para el usuario: " + tutorEmail));
        Disponibilidad disponibilidad = disponibilidadRepository.findById(disponibilidadId)
                .orElseThrow(() -> new ResourceNotFoundException("Disponibilidad no encontrada con ID: " + disponibilidadId));
        if (!Objects.equals(disponibilidad.getTutor().getId(), tutor.getId())) {
            throw new ForbiddenException("No tienes permiso para modificar esta disponibilidad.");
        }
        long sesionesActivas = sesionRepository.countSesionesActivasEnRango(
                disponibilidad.getTutor().getId(),
                disponibilidad.getFecha(),
                disponibilidad.getHoraInicial(),
                disponibilidad.getHoraFinal()
        );
        if (sesionesActivas > 0) {
            throw new BadRequestException("No se puede modificar la disponibilidad porque ya tiene sesiones reservadas o confirmadas en este horario.");
        }
        LocalDateTime nuevaHoraInicial = LocalDateTime.of(request.getFecha(), request.getHoraInicio());
        LocalDateTime nuevaHoraFinal = LocalDateTime.of(request.getFecha(), request.getHoraFinal());
        if (nuevaHoraFinal.isBefore(nuevaHoraInicial) || nuevaHoraFinal.equals(nuevaHoraInicial)) {
            throw new BadRequestException("La hora de finalización debe ser posterior a la hora de inicio.");
        }
        List<Disponibilidad> disponibilidadesSolapadas = disponibilidadRepository
                .findDisponibilidadesSolapadasExcluyendoActual(tutor.getId(), request.getFecha(), nuevaHoraInicial, nuevaHoraFinal, disponibilidadId);
        if (!disponibilidadesSolapadas.isEmpty()) {
            throw new BadRequestException("La disponibilidad actualizada se solapa con otra existente.");
        }
        disponibilidad.setFecha(request.getFecha());
        disponibilidad.setHoraInicial(nuevaHoraInicial);
        disponibilidad.setHoraFinal(nuevaHoraFinal);
        Disponibilidad actualizada = disponibilidadRepository.save(disponibilidad);
        return disponibilidadMapper.toDisponibilidadResponse(actualizada);
    }
    @Override
    @Transactional
    public void deleteDisponibilidad(String tutorEmail, Long disponibilidadId) {
        User userTutor = userRepository.findByEmail(tutorEmail)
                .orElseThrow(() -> new ResourceNotFoundException("Usuario tutor no encontrado: " + tutorEmail));
        Tutor tutor = tutorRepository.findByUser(userTutor)
                .orElseThrow(() -> new ResourceNotFoundException("Perfil de tutor no encontrado para el usuario: " + tutorEmail));
        Disponibilidad disponibilidad = disponibilidadRepository.findById(disponibilidadId)
                .orElseThrow(() -> new ResourceNotFoundException("Disponibilidad no encontrada con ID: " + disponibilidadId));
        if (!Objects.equals(disponibilidad.getTutor().getId(), tutor.getId())) {
            throw new ForbiddenException("No tienes permiso para eliminar esta disponibilidad.");
        }
        long sesionesActivas = sesionRepository.countSesionesActivasEnRango(
                disponibilidad.getTutor().getId(),
                disponibilidad.getFecha(),
                disponibilidad.getHoraInicial(),
                disponibilidad.getHoraFinal()
        );
        if (sesionesActivas > 0) {
            throw new BadRequestException("No se puede eliminar la disponibilidad porque ya tiene sesiones reservadas o confirmadas en este horario.");
        }
        disponibilidadRepository.delete(disponibilidad);
    }
    @Override
    @Transactional(readOnly = true)
    public List<DisponibilidadResponse> getDisponibilidadesByTutorId(Long tutorId) {
        Tutor tutor = tutorRepository.findById(tutorId)
                .orElseThrow(() -> new ResourceNotFoundException("Tutor no encontrado con ID: " + tutorId));
        List<Disponibilidad> disponibilidades = disponibilidadRepository.findByTutorOrderByFechaAscHoraInicialAsc(tutor);
         List<Disponibilidad> disponibilidadesFuturas = disponibilidades.stream()
                .filter(d -> d.getHoraInicial().isAfter(LocalDateTime.now()))
                .collect(Collectors.toList());
        return disponibilidadMapper.toDisponibilidadResponseList(disponibilidades);
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\EnlaceSesionService.java
package tutorgo.com.service;
import tutorgo.com.dto.request.EnlaceSesionRequestDTO;
import tutorgo.com.dto.response.EnlaceSesionResponseDTO;
import java.util.List;
public interface EnlaceSesionService
{
    List<EnlaceSesionResponseDTO> guardarEnlaces(Long sesionId, List<EnlaceSesionRequestDTO> enlaces, String emailTutor);
    List<EnlaceSesionResponseDTO> obtenerEnlacesPorSesion(Long sesionId);
    void eliminarEnlacePorId(Long enlaceId, String emailTutor);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\EnlaceSesionServiceImpl.java
package tutorgo.com.service;
import lombok.RequiredArgsConstructor;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tutorgo.com.dto.request.EnlaceSesionRequestDTO;
import tutorgo.com.dto.response.EnlaceSesionResponseDTO;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.mapper.EnlaceSesionMapper;
import tutorgo.com.model.EnlaceSesion;
import tutorgo.com.model.Sesion;
import tutorgo.com.model.Tutor;
import tutorgo.com.model.User;
import tutorgo.com.repository.EnlaceSesionRepository;
import tutorgo.com.repository.SesionRepository;
import java.util.List;
import java.util.stream.Collectors;
@Service
@RequiredArgsConstructor
public class EnlaceSesionServiceImpl implements EnlaceSesionService {
    private final EnlaceSesionRepository enlaceSesionRepository;
    private final SesionRepository sesionRepository;
    private final EnlaceSesionMapper enlaceSesionMapper;
    private static final int MAX_ENLACES = 5;
    @Override
    public void eliminarEnlacePorId(Long enlaceId, String emailTutorAutenticado) {
        EnlaceSesion enlaceSesion = enlaceSesionRepository.findById(enlaceId)
                .orElseThrow(() -> new RuntimeException("Enlace no encontrado"));
        Sesion sesion = enlaceSesion.getSesion();
        Tutor tutorSesion = sesion.getTutor();
        User userTutor = tutorSesion.getUser();
        if (!userTutor.getEmail().equalsIgnoreCase(emailTutorAutenticado)) {
            throw new AccessDeniedException("No tienes permiso para eliminar este enlace.");
        }
        enlaceSesionRepository.delete(enlaceSesion);
    }
    @Override
    public List<EnlaceSesionResponseDTO> guardarEnlaces(Long sesionId, List<EnlaceSesionRequestDTO> enlacesDTO, String emailTutorAutenticado) {
        Sesion sesion = sesionRepository.findById(sesionId)
                .orElseThrow(() -> new RuntimeException("Sesión no encontrada"));
        String emailDelCreador = sesion.getTutor().getUser().getEmail();
        if (!emailDelCreador.equalsIgnoreCase(emailTutorAutenticado)) {
            throw new AccessDeniedException("No tienes permiso para agregar enlaces a esta sesión.");
        }
        int enlacesActuales = sesion.getEnlaces() != null ? sesion.getEnlaces().size() : 0;
        if (enlacesActuales + enlacesDTO.size() > 5) {
            throw new IllegalStateException("No se pueden agregar más de 5 enlaces por sesión.");
        }
        List<EnlaceSesion> enlaces = enlacesDTO.stream()
                .map(dto -> {
                    EnlaceSesion enlace = new EnlaceSesion();
                    enlace.setNombre(dto.getNombre());
                    enlace.setEnlace(dto.getEnlace());
                    enlace.setSesion(sesion);
                    return enlace;
                })
                .toList();
        List<EnlaceSesion> guardados = enlaceSesionRepository.saveAll(enlaces);
        return guardados.stream()
                .map(enlaceSesionMapper::toResponseDTO)
                .toList();
    }
    @Override
    @Transactional(readOnly = true)
    public List<EnlaceSesionResponseDTO> obtenerEnlacesPorSesion(Long sesionId) {
        return enlaceSesionRepository.findBySesionId(sesionId).stream()
                .map(enlaceSesionMapper::toDTO)
                .collect(Collectors.toList());
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\NotificacionSenderService.java
package tutorgo.com.service;
import tutorgo.com.model.Sesion;
public interface NotificacionSenderService {
    void enviarRecordatorioSesion(Sesion sesion);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\NotificacionSenderServiceImpl.java
package tutorgo.com.service;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import tutorgo.com.enums.TipoNotificacionEstEnum;
import tutorgo.com.enums.TipoNotificacionTutorEnum;
import tutorgo.com.model.*;
import tutorgo.com.repository.NotificacionEstudianteRepository;
import tutorgo.com.repository.NotificacionTutorRepository;
import java.time.format.DateTimeFormatter;
@Service
@RequiredArgsConstructor
public class NotificacionSenderServiceImpl implements NotificacionSenderService {
    private final NotificacionEstudianteRepository notificacionEstudianteRepository;
    private final NotificacionTutorRepository notificacionTutorRepository;
    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("dd 'de' MMMM 'a las' HH:mm");
    @Override
    public void enviarRecordatorioSesion(Sesion sesion) {
        if (sesion == null || sesion.getEstudiante() == null || sesion.getTutor() == null) {
            return;
        }
        enviarRecordatorioAEstudiante(sesion);
        enviarRecordatorioATutor(sesion);
    }
    private void enviarRecordatorioAEstudiante(Sesion sesion) {
        Estudiante estudiante = sesion.getEstudiante();
        String titulo = "⏰ Recordatorio de tu tutoría";
        String texto = String.format(
                "Hola %s, te recordamos que tienes una sesión de %s con %s el %s.",
                estudiante.getUser().getNombre().split(" ")[0],
                sesion.getTutor().getRubro(),
                sesion.getTutor().getUser().getNombre(),
                sesion.getHoraInicial().format(FORMATTER)
        );
        NotificacionEstudiante notificacion = new NotificacionEstudiante();
        notificacion.setEstudiante(estudiante);
        notificacion.setTipo(TipoNotificacionEstEnum.RECORDATORIO);
        notificacion.setTitulo(titulo);
        notificacion.setTexto(texto);
        notificacionEstudianteRepository.save(notificacion);
    }
    private void enviarRecordatorioATutor(Sesion sesion) {
        Tutor tutor = sesion.getTutor();
        String titulo = "⏰ Recordatorio de tu próxima clase";
        String texto = String.format(
                "Hola %s, te recordamos tu clase de %s con %s el %s.",
                tutor.getUser().getNombre().split(" ")[0],
                tutor.getRubro(),
                sesion.getEstudiante().getUser().getNombre(),
                sesion.getHoraInicial().format(FORMATTER)
        );
        NotificacionTutor notificacion = new NotificacionTutor();
        notificacion.setTutor(tutor);
        notificacion.setTipo(TipoNotificacionTutorEnum.RECORDATORIO);
        notificacion.setTitulo(titulo);
        notificacion.setTexto(texto);
        notificacionTutorRepository.save(notificacion);
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\NotificacionService.java
package tutorgo.com.service;
import tutorgo.com.dto.response.NotificacionResponse;
import tutorgo.com.model.Estudiante;
import tutorgo.com.model.Tutor;
import tutorgo.com.model.Sesion;
import java.util.List;
public interface NotificacionService {
    List<NotificacionResponse> getMisNotificaciones(String userEmail);
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\NotificacionServiceImpl.java
package tutorgo.com.service;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import tutorgo.com.dto.response.NotificacionResponse;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.model.*;
import tutorgo.com.repository.*;
import java.util.List;
import java.util.stream.Collectors;
@Service
@RequiredArgsConstructor
public class NotificacionServiceImpl implements NotificacionService {
    private final UserRepository userRepository;
    private final NotificacionEstudianteRepository notificacionEstudianteRepository;
    private final NotificacionTutorRepository notificacionTutorRepository;
    @Override
    public List<NotificacionResponse> getMisNotificaciones(String userEmail) {
        User user = userRepository.findByEmail(userEmail)
                .orElseThrow(() -> new ResourceNotFoundException("Usuario no encontrado"));
        if ("ESTUDIANTE".equals(user.getRole().getNombre().name())) {
            Estudiante estudiante = user.getStudentProfile();
            if (estudiante == null) return List.of();
            return notificacionEstudianteRepository.findByEstudianteOrderByFechaCreacionDesc(estudiante)
                    .stream()
                    .map(this::mapToResponse)
                    .collect(Collectors.toList());
        } else if ("TUTOR".equals(user.getRole().getNombre().name())) {
            Tutor tutor = user.getTutorProfile();
            if (tutor == null) return List.of();
            return notificacionTutorRepository.findByTutorOrderByFechaCreacionDesc(tutor)
                    .stream()
                    .map(this::mapToResponse)
                    .collect(Collectors.toList());
        }
        return List.of(); // Si es ADMIN o rol no reconocido, no devuelve nada.
    }
    private NotificacionResponse mapToResponse(NotificacionEstudiante n) {
        return new NotificacionResponse(n.getId(), n.getTitulo(), n.getTexto(), n.getTipo().name(), n.getFechaCreacion());
    }
    private NotificacionResponse mapToResponse(NotificacionTutor n) {
        return new NotificacionResponse(n.getId(), n.getTitulo(), n.getTexto(), n.getTipo().name(), n.getFechaCreacion());
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\PagoService.java
package tutorgo.com.service;
import java.util.List;
import org.springframework.data.domain.Pageable; // Importar
import tutorgo.com.dto.request.ConfirmarPagoRequest;
import tutorgo.com.dto.response.PagedResponse; // Importar
import tutorgo.com.dto.response.PagoResponse;
public interface PagoService {
    PagoResponse procesarPagoYConfirmarSesion(String alumnoEmail, ConfirmarPagoRequest request);
    List<PagoResponse> obtenerHistorialTransacciones(String userEmail);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\PagoServiceImpl.java
package tutorgo.com.service;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tutorgo.com.dto.request.ConfirmarPagoRequest;
import tutorgo.com.dto.response.PagedResponse;
import tutorgo.com.dto.response.PagoResponse;
import tutorgo.com.enums.EstadoPagoEnum;
import tutorgo.com.enums.EstadoSesionEnum;
import tutorgo.com.enums.RoleName;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.exception.ForbiddenException;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.mapper.PagoMapper;
import tutorgo.com.model.*;
import tutorgo.com.repository.*;
import java.math.BigDecimal;
import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
@Service
@RequiredArgsConstructor
public class PagoServiceImpl implements PagoService {
    private final UserRepository userRepository;
    private final EstudianteRepository estudianteRepository;
    private final TutorRepository tutorRepository;
    private final SesionRepository sesionRepository;
    private final PagoRepository pagoRepository;
    private final DisponibilidadRepository disponibilidadRepository;
    private final PagoMapper pagoMapper;
    private static final BigDecimal PORCENTAJE_COMISION_PLATAFORMA = new BigDecimal("0.10");
    @Override
    @Transactional
    public PagoResponse procesarPagoYConfirmarSesion(String alumnoEmail, ConfirmarPagoRequest request) {
        User userAlumno = userRepository.findByEmail(alumnoEmail)
                .orElseThrow(() -> new ResourceNotFoundException("Usuario alumno no encontrado: " + alumnoEmail));
        Estudiante alumno = estudianteRepository.findByUser(userAlumno)
                .orElseThrow(() -> new ResourceNotFoundException("Perfil de estudiante no encontrado para el usuario: " + alumnoEmail));
        Sesion sesion = sesionRepository.findById(request.getSesionId())
                .orElseThrow(() -> new ResourceNotFoundException("Sesión no encontrada con ID: " + request.getSesionId()));
        if (!Objects.equals(sesion.getEstudiante().getId(), alumno.getId())) {
            throw new ForbiddenException("No tienes permiso para pagar esta sesión.");
        }
        if (sesion.getTipoEstado() != EstadoSesionEnum.PENDIENTE) {
            throw new BadRequestException("Esta sesión no está pendiente de pago o ya ha sido procesada.");
        }
        Tutor tutor = sesion.getTutor();
        if (tutor == null) {
            throw new IllegalStateException("La sesión con ID " + sesion.getId() + " no tiene un tutor asignado.");
        }
        long duracionMinutos = Duration.between(sesion.getHoraInicial(), sesion.getHoraFinal()).toMinutes();
        if (duracionMinutos <= 0) {
            throw new BadRequestException("La duración de la sesión es inválida.");
        }
        BigDecimal tarifaPorMinuto = BigDecimal.valueOf(tutor.getTarifaHora()).divide(BigDecimal.valueOf(60), 2, BigDecimal.ROUND_HALF_UP);
        BigDecimal montoTotal = tarifaPorMinuto.multiply(BigDecimal.valueOf(duracionMinutos));
        BigDecimal comision = montoTotal.multiply(PORCENTAJE_COMISION_PLATAFORMA).setScale(2, BigDecimal.ROUND_HALF_UP);
        Pago pago = new Pago();
        pago.setEstudiante(alumno);
        pago.setTutor(tutor);
        pago.setMonto(montoTotal);
        pago.setComisionPlataforma(comision);
        pago.setMetodoPago(request.getMetodoPago());
        pago.setTipoEstado(EstadoPagoEnum.COMPLETADO);
        Pago pagoGuardado = pagoRepository.save(pago);
        sesion.setTipoEstado(EstadoSesionEnum.CONFIRMADO);
        sesionRepository.save(sesion);
        ajustarDisponibilidadDelTutor(sesion);
        PagoResponse pagoDto = pagoMapper.toPagoResponse(pagoGuardado);
        if (pagoDto != null) { // pagoMapper puede devolver null si pagoGuardado es null
            pagoDto.setSesionId(sesion.getId());
        }
        return pagoDto;
    }
    private void ajustarDisponibilidadDelTutor(Sesion sesionConfirmada) {
        Tutor tutor = sesionConfirmada.getTutor();
        LocalDateTime inicioSesion = sesionConfirmada.getHoraInicial();
        LocalDateTime finSesion = sesionConfirmada.getHoraFinal();
        List<Disponibilidad> disponibilidadesOriginales = disponibilidadRepository
                .findDisponibilidadQueEnvuelveElSlot(
                        tutor.getId(),
                        sesionConfirmada.getFecha(),
                        inicioSesion,
                        finSesion);
        if (disponibilidadesOriginales.isEmpty()) {
            System.err.println("ADVERTENCIA: No se encontró la disponibilidad original para la sesión ID: " + sesionConfirmada.getId() +
                    ". No se pudo ajustar la disponibilidad del tutor.");
            return;
        }
        Disponibilidad dispOriginal = disponibilidadesOriginales.get(0);
        if (dispOriginal.getHoraInicial().equals(inicioSesion) && dispOriginal.getHoraFinal().equals(finSesion)) {
            disponibilidadRepository.delete(dispOriginal);
        }
        else if (dispOriginal.getHoraInicial().equals(inicioSesion) && finSesion.isBefore(dispOriginal.getHoraFinal())) {
            dispOriginal.setHoraInicial(finSesion);
            disponibilidadRepository.save(dispOriginal);
        }
        else if (inicioSesion.isAfter(dispOriginal.getHoraInicial()) && dispOriginal.getHoraFinal().equals(finSesion)) {
            dispOriginal.setHoraFinal(inicioSesion);
            disponibilidadRepository.save(dispOriginal);
        }
        else if (inicioSesion.isAfter(dispOriginal.getHoraInicial()) && finSesion.isBefore(dispOriginal.getHoraFinal())) {
            LocalDateTime finOriginal = dispOriginal.getHoraFinal();
            dispOriginal.setHoraFinal(inicioSesion);
            disponibilidadRepository.save(dispOriginal);
            Disponibilidad nuevaDispDespues = new Disponibilidad();
            nuevaDispDespues.setTutor(tutor);
            nuevaDispDespues.setFecha(dispOriginal.getFecha());
            nuevaDispDespues.setHoraInicial(finSesion);
            nuevaDispDespues.setHoraFinal(finOriginal);
            disponibilidadRepository.save(nuevaDispDespues);
        } else {
            System.err.println("ADVERTENCIA: Lógica de ajuste de disponibilidad no cubre el caso para sesión ID: " + sesionConfirmada.getId() +
                    " y disponibilidad ID: " + dispOriginal.getId());
        }
    }
    @Override
    public List<PagoResponse> obtenerHistorialTransacciones(String userEmail) {
        return userRepository.findByEmail(userEmail).map(u -> {
            if (u.getStudentProfile() != null) {
                return pagoRepository.findByEstudianteIdWithDetails(u.getStudentProfile().getId())
                        .stream().map(pagoMapper::toPagoResponse).collect(Collectors.toList());
            } else if (u.getTutorProfile() != null) {
                return pagoRepository.findByTutorIdWithDetails(u.getTutorProfile().getId())
                        .stream().map(pagoMapper::toPagoResponse).collect(Collectors.toList());
            }
            return List.<PagoResponse>of();
        }).orElse(List.of());
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\ResenaService.java
package tutorgo.com.service;
import tutorgo.com.dto.request.ResenaRequestDTO;
import tutorgo.com.dto.response.ResenaResponseDTO;
public interface ResenaService {
    ResenaResponseDTO crearResena(Long sesionId, ResenaRequestDTO requestDTO, String emailEstudiante);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\ResenaServiceImpl.java
package tutorgo.com.service;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tutorgo.com.dto.request.ResenaRequestDTO;
import tutorgo.com.dto.response.ResenaResponseDTO;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.mapper.ResenaMapper;
import tutorgo.com.model.Resena;
import tutorgo.com.model.Sesion;
import tutorgo.com.model.Tutor;
import tutorgo.com.repository.ResenaRepository;
import tutorgo.com.repository.SesionRepository;
import tutorgo.com.repository.TutorRepository;
import java.util.List; // ***** NUEVA IMPORTACIÓN *****
@Service
@RequiredArgsConstructor
public class ResenaServiceImpl implements ResenaService {
    private final ResenaRepository resenaRepository;
    private final SesionRepository sesionRepository;
    private final TutorRepository tutorRepository;
    private final ResenaMapper resenaMapper;
    @Override
    @Transactional
    public ResenaResponseDTO crearResena(Long sesionId, ResenaRequestDTO requestDTO, String emailEstudiante) {
        if (requestDTO.getCalificacion() == null || requestDTO.getCalificacion() < 1 || requestDTO.getCalificacion() > 5) {
            throw new BadRequestException("La calificación debe ser entre 1 y 5");
        }
        if (requestDTO.getComentario() != null && requestDTO.getComentario().length() > 500) {
            throw new BadRequestException("El comentario no puede exceder los 500 caracteres");
        }
        Sesion sesion = sesionRepository.findById(sesionId)
                .orElseThrow(() -> new ResourceNotFoundException("Sesión no encontrada con ID: " + sesionId));
        if (resenaRepository.existsBySesionId(sesionId)) {
            throw new BadRequestException("Esta sesión ya tiene una reseña registrada");
        }
        String emailSesionEstudiante = sesion.getEstudiante().getUser().getEmail();
        if (!emailSesionEstudiante.equalsIgnoreCase(emailEstudiante)) {
            throw new BadRequestException("No tienes permiso para calificar esta sesión.");
        }
        Resena resena = resenaMapper.toEntity(requestDTO);
        resena.setSesion(sesion);
        Resena guardada = resenaRepository.save(resena);
        actualizarPromedioEstrellasTutor(sesion.getTutor());
        return resenaMapper.toDTO(guardada);
    }
    private void actualizarPromedioEstrellasTutor(Tutor tutor) {
        List<Sesion> sesionesConResena = tutor.getSesionesComoTutor().stream()
                .filter(s -> s.getResena() != null)
                .toList();
        if (sesionesConResena.isEmpty()) {
            tutor.setEstrellasPromedio(0.0f); // Si no hay reseñas, el promedio es 0
        } else {
            double promedio = sesionesConResena.stream()
                    .mapToInt(s -> s.getResena().getCalificacion())
                    .average()
                    .orElse(0.0);
            tutor.setEstrellasPromedio((float) promedio);
        }
        tutorRepository.save(tutor);
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\SesionProgramadaService.java
package tutorgo.com.service;
import tutorgo.com.dto.response.SesionProgramadaResponseDTO;
public interface SesionProgramadaService {
    SesionProgramadaResponseDTO obtenerSesionProgramadaDelEstudianteAutenticado(String emailEstudiante);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\SesionProgramadaServiceImpl.java
package tutorgo.com.service;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import tutorgo.com.dto.response.SesionProgramadaResponseDTO;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.mapper.SesionProgramadaMapper;
import tutorgo.com.model.Estudiante;
import tutorgo.com.model.Sesion;
import tutorgo.com.repository.EstudianteRepository;
import tutorgo.com.repository.SesionRepository;
import java.time.LocalDateTime;
import java.util.Optional;
@Service
@RequiredArgsConstructor
public class SesionProgramadaServiceImpl implements SesionProgramadaService {
    private final EstudianteRepository estudianteRepository;
    private final SesionRepository sesionRepository;
    private final SesionProgramadaMapper sesionProgramadaMapper;
    @Override
    public SesionProgramadaResponseDTO obtenerSesionProgramadaDelEstudianteAutenticado(String emailEstudiante) {
        Estudiante estudiante = estudianteRepository.findByUserEmail(emailEstudiante)
                .orElseThrow(() -> new BadRequestException("Estudiante no encontrado."));
        Optional<Sesion> sesionProgramada = estudiante.getSesionesComoEstudiante().stream()
                .filter(s -> s.getHoraInicial().isAfter(LocalDateTime.now()))
                .sorted((s1, s2) -> s1.getHoraInicial().compareTo(s2.getHoraInicial()))
                .findFirst();
        if (sesionProgramada.isPresent()) {
            return sesionProgramadaMapper.toResponseDTO(sesionProgramada.get());
        }
        SesionProgramadaResponseDTO dto = new SesionProgramadaResponseDTO();
        dto.setSesionId(null);
        dto.setEnlaceDisponible(false);
        dto.setMensaje("No tienes sesiones programadas próximamente.");
        return dto;
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\SesionService.java
package tutorgo.com.service;
import tutorgo.com.dto.request.ReservaTutoriaRequest;
import tutorgo.com.dto.response.SesionResponse;
import org.springframework.data.domain.Pageable;
import tutorgo.com.dto.response.PagedResponse;
import java.util.List;
public interface SesionService {
    SesionResponse reservarTutoria(String alumnoEmail, ReservaTutoriaRequest request);
    List<SesionResponse> getSesionesByAlumnoEmail(String alumnoEmail);
    List<SesionResponse> getSesionesByTutorEmail(String tutorEmail);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\SesionServiceImpl.java
package tutorgo.com.service;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tutorgo.com.dto.request.ReservaTutoriaRequest;
import tutorgo.com.dto.response.SesionResponse;
import tutorgo.com.enums.EstadoSesionEnum;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.mapper.SesionMapper;
import tutorgo.com.model.*; // Importar Estudiante, Tutor, User, Sesion, Disponibilidad
import tutorgo.com.repository.*; // Importar los repositorios necesarios
import java.time.LocalDateTime;
import java.util.List;
@Service
@RequiredArgsConstructor
public class SesionServiceImpl implements SesionService {
    private final UserRepository userRepository;
    private final EstudianteRepository estudianteRepository;
    private final TutorRepository tutorRepository;
    private final SesionRepository sesionRepository;
    private final DisponibilidadRepository disponibilidadRepository; // Para verificar disponibilidad
    private final SesionMapper sesionMapper;
    @Override
    @Transactional
    public SesionResponse reservarTutoria(String alumnoEmail, ReservaTutoriaRequest request) {
        Estudiante alumno = estudianteRepository.findByUserEmail(alumnoEmail)
                .orElseThrow(() -> new ResourceNotFoundException("Perfil de estudiante no encontrado"));
        Tutor tutor = tutorRepository.findById(request.getTutorId())
                .orElseThrow(() -> new ResourceNotFoundException("Tutor no encontrado con ID: " + request.getTutorId()));
        LocalDateTime horaInicialDateTime = LocalDateTime.of(request.getFecha(), request.getHoraInicio());
        LocalDateTime horaFinalDateTime = LocalDateTime.of(request.getFecha(), request.getHoraFinal());
        if (horaFinalDateTime.isBefore(horaInicialDateTime) || horaFinalDateTime.equals(horaInicialDateTime)) {
            throw new BadRequestException("La hora de finalización debe ser posterior a la hora de inicio.");
        }
        if (horaInicialDateTime.isBefore(LocalDateTime.now())) {
            throw new BadRequestException("No se pueden reservar tutorías en el pasado.");
        }
        List<Disponibilidad> disponibilidadesQueCubren = disponibilidadRepository
                .findDisponibilidadQueEnvuelveElSlot(
                        tutor.getId(),
                        request.getFecha(),
                        horaInicialDateTime,
                        horaFinalDateTime
                );
        if (disponibilidadesQueCubren.isEmpty()) {
            throw new BadRequestException("El horario solicitado no está dentro de la disponibilidad del tutor.");
        }
        List<Sesion> sesionesSolapadas = sesionRepository
                .findSesionesSolapadasParaTutor(tutor.getId(), request.getFecha(), horaInicialDateTime, horaFinalDateTime);
        if (!sesionesSolapadas.isEmpty()) {
            throw new BadRequestException("El horario seleccionado ya no está disponible o está ocupado.");
        }
        Sesion nuevaSesion = new Sesion();
        nuevaSesion.setEstudiante(alumno);
        nuevaSesion.setTutor(tutor);
        nuevaSesion.setFecha(request.getFecha());
        nuevaSesion.setHoraInicial(horaInicialDateTime);
        nuevaSesion.setHoraFinal(horaFinalDateTime);
        nuevaSesion.setTipoEstado(EstadoSesionEnum.PENDIENTE);
        Sesion sesionGuardada = sesionRepository.save(nuevaSesion);
        return sesionMapper.toSesionResponse(sesionGuardada);
    }
    @Override
    @Transactional(readOnly = true)
    public List<SesionResponse> getSesionesByAlumnoEmail(String alumnoEmail) {
        List<Sesion> sesiones = sesionRepository.findByEstudiante_User_EmailOrderByFechaAscHoraInicialAsc(alumnoEmail);
        return sesionMapper.toSesionResponseList(sesiones);
    }
    @Override
    @Transactional(readOnly = true)
    public List<SesionResponse> getSesionesByTutorEmail(String tutorEmail) {
        List<Sesion> sesiones = sesionRepository.findByTutor_User_EmailOrderByFechaAscHoraInicialAsc(tutorEmail);
        return sesionMapper.toSesionResponseList(sesiones);
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\TutorService.java
package tutorgo.com.service;
import org.springframework.data.domain.Pageable;
import tutorgo.com.dto.response.PagedResponse;
import tutorgo.com.dto.response.TutorProfileResponse;
import tutorgo.com.dto.response.TutorSummaryResponse;
public interface TutorService {
    PagedResponse<TutorSummaryResponse> getAllTutores(String query, Integer maxPrecio, Float puntuacion, Pageable pageable);
    TutorProfileResponse getTutorProfile(Long tutorId);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\TutorServiceImpl.java
package tutorgo.com.service;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import tutorgo.com.dto.response.PagedResponse;
import tutorgo.com.dto.response.TutorProfileResponse;
import tutorgo.com.dto.response.TutorSummaryResponse;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.mapper.TutorMapper;
import tutorgo.com.model.Tutor;
import tutorgo.com.model.User;
import tutorgo.com.repository.TutorRepository;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
@Service
@RequiredArgsConstructor
public class TutorServiceImpl implements TutorService {
    private final TutorRepository tutorRepository;
    private final TutorMapper tutorMapper;
    @Override
    @Transactional(readOnly = true)
    public PagedResponse<TutorSummaryResponse> getAllTutores(String query, Integer maxPrecio, Float puntuacion, Pageable pageable) {
        List<Tutor> tutoresPrefiltrados = tutorRepository.findWithNumericFilters(maxPrecio, puntuacion);
        List<Tutor> tutoresFiltrados;
        if (StringUtils.hasText(query)) {
            String lowerCaseQuery = query.trim().toLowerCase();
            tutoresFiltrados = tutoresPrefiltrados.stream()
                    .filter(tutor -> {
                        boolean nombreCoincide = tutor.getUser() != null && tutor.getUser().getNombre().toLowerCase().contains(lowerCaseQuery);
                        boolean rubroCoincide = tutor.getRubro().toLowerCase().contains(lowerCaseQuery);
                        return nombreCoincide || rubroCoincide;
                    })
                    .collect(Collectors.toList());
        } else {
            tutoresFiltrados = tutoresPrefiltrados;
        }
        int start = (int) pageable.getOffset();
        int end = Math.min((start + pageable.getPageSize()), tutoresFiltrados.size());
        List<Tutor> paginaDeTutores = (start <= end) ? tutoresFiltrados.subList(start, end) : Collections.emptyList();
        List<TutorSummaryResponse> dtos = tutorMapper.tutorsToTutorSummaryResponseList(paginaDeTutores);
        return new PagedResponse<>(
                dtos,
                pageable.getPageNumber(),
                pageable.getPageSize(),
                tutoresFiltrados.size(), // El total de elementos es el de la lista filtrada
                (int) Math.ceil((double) tutoresFiltrados.size() / pageable.getPageSize()), // Cálculo de páginas totales
                pageable.getPageNumber() >= (int) Math.ceil((double) tutoresFiltrados.size() / pageable.getPageSize()) - 1
        );
    }
    @Override
    @Transactional(readOnly = true)
    public TutorProfileResponse getTutorProfile(Long tutorId) {
        Tutor tutor = tutorRepository.findById(tutorId)
                .orElseThrow(() -> new ResourceNotFoundException("Tutor no encontrado"));
        TutorProfileResponse response = new TutorProfileResponse();
        response.setId(tutor.getId());
        response.setTarifaHora(tutor.getTarifaHora());
        response.setRubro(tutor.getRubro());
        response.setBio(tutor.getBio());
        response.setEstrellasPromedio(tutor.getEstrellasPromedio());
        User user = tutor.getUser();
        if (user != null) {
            response.setNombreUsuario(user.getNombre());
            response.setFotoUrlUsuario(user.getFotoUrl());
        }
        return response;
    }
};
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\UserDetailsService.java
package tutorgo.com.service;
public class UserDetailsService {
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\UserDetailsServiceImpl.java
package tutorgo.com.security;
import tutorgo.com.model.User;
import tutorgo.com.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import java.util.HashSet;
import java.util.Set;
@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {
    private final UserRepository userRepository;
    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() ->
                        new UsernameNotFoundException("Usuario no encontrado con el correo electrónico: " + email));
        Set<GrantedAuthority> authorities = new HashSet<>();
        if (user.getRole() != null) {
            authorities.add(new SimpleGrantedAuthority("ROLE_" + user.getRole().getNombre().name()));
        } else {
            authorities.add(new SimpleGrantedAuthority("ROLE_ANONYMOUS"));
        }
        return new CustomUserDetails(user, authorities);
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\UserService.java
package tutorgo.com.service;
import tutorgo.com.dto.request.UpdatePasswordRequest;
import tutorgo.com.dto.request.UpdateUserProfileRequest;
import tutorgo.com.dto.request.UserRegistrationRequest;
import tutorgo.com.dto.response.UserResponse;
public interface UserService {
    UserResponse registerUser(UserRegistrationRequest registrationRequest);
    void updatePassword(String userEmail, UpdatePasswordRequest updatePasswordRequest);
    UserResponse updateUserProfile(String userEmail, UpdateUserProfileRequest updateUserProfileRequest);
    void deleteUserProfile(String userEmail);
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\service\UserServiceImpl.java
package tutorgo.com.service;
import tutorgo.com.dto.request.UpdatePasswordRequest;
import tutorgo.com.dto.request.UpdateUserProfileRequest;
import tutorgo.com.dto.request.UserRegistrationRequest;
import tutorgo.com.dto.response.UserResponse;
import tutorgo.com.enums.RoleName;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.exception.DuplicateResourceException;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.mapper.UserMapper;
import tutorgo.com.model.Estudiante;
import tutorgo.com.model.Role;
import tutorgo.com.model.Tutor;
import tutorgo.com.model.User;
import tutorgo.com.repository.EstudianteRepository;
import tutorgo.com.repository.RoleRepository;
import tutorgo.com.repository.TutorRepository;
import tutorgo.com.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final TutorRepository tutorRepository;
    private final EstudianteRepository estudianteRepository;
    private final PasswordEncoder passwordEncoder;
    private final UserMapper userMapper;
    @Override
    @Transactional
    public UserResponse registerUser(UserRegistrationRequest request) {
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new DuplicateResourceException("Este correo ya está registrado. Pruebe iniciando sesión.");
        }
        Role userRole = roleRepository.findByNombre(request.getRol())
                .orElseThrow(() -> new BadRequestException("Rol no válido: " + request.getRol()));
        User user = new User();
        user.setNombre(request.getNombre());
        user.setEmail(request.getEmail());
        user.setPassword(passwordEncoder.encode(request.getPassword()));
        user.setRole(userRole);
        user.setFotoUrl(request.getFotoUrl());
        User savedUser = userRepository.save(user);
        if (userRole.getNombre() == RoleName.TUTOR) {
            if (request.getTarifaHora() == null || !StringUtils.hasText(request.getRubro())) {
                userRepository.delete(savedUser);
                throw new BadRequestException("Para el rol TUTOR, la tarifa por hora y el rubro son obligatorios.");
            }
            Tutor tutorProfile = new Tutor();
            tutorProfile.setUser(savedUser);
            tutorProfile.setTarifaHora(request.getTarifaHora());
            tutorProfile.setRubro(request.getRubro());
            tutorProfile.setBio(request.getBio());
            tutorProfile.setEstrellasPromedio(0.0f);
            Tutor savedTutorProfile = tutorRepository.save(tutorProfile);
            savedUser.setTutorProfile(savedTutorProfile);
        } else if (userRole.getNombre() == RoleName.ESTUDIANTE) {
            if (!StringUtils.hasText(request.getCentroEstudio())) {
                userRepository.delete(savedUser);
                throw new BadRequestException("Para el rol ESTUDIANTE, el centro de estudio es obligatorio.");
            }
            Estudiante studentProfile = new Estudiante();
            studentProfile.setUser(savedUser);
            studentProfile.setCentroEstudio(request.getCentroEstudio());
            Estudiante savedStudentProfile = estudianteRepository.save(studentProfile);
            savedUser.setStudentProfile(savedStudentProfile);
        }
        return userMapper.userToUserResponse(savedUser);
    }
    @Override
    @Transactional
    public void updatePassword(String userEmail, UpdatePasswordRequest request) {
        User user = userRepository.findByEmailWithProfiles(userEmail)
                .orElseThrow(() -> new ResourceNotFoundException("Usuario no encontrado con email: " + userEmail));
        if (!passwordEncoder.matches(request.getCurrentPassword(), user.getPassword())) {
            throw new BadRequestException("La contraseña actual ingresada es incorrecta.");
        }
        if (!request.getNewPassword().equals(request.getConfirmNewPassword())) {
            throw new BadRequestException("La nueva contraseña y su confirmación no coinciden.");
        }
        if (passwordEncoder.matches(request.getNewPassword(), user.getPassword())) {
            throw new BadRequestException("La nueva contraseña no puede ser igual a la contraseña actual.");
        }
        user.setPassword(passwordEncoder.encode(request.getNewPassword()));
        userRepository.save(user);
    }
    @Override
    @Transactional
    public UserResponse updateUserProfile(String userEmail, UpdateUserProfileRequest request) {
        User user = userRepository.findByEmail(userEmail)
                .orElseThrow(() -> new ResourceNotFoundException("Usuario no encontrado con email: " + userEmail));
        user.setNombre(request.getNombre());
        if (request.getFotoUrl() != null) { // Si el campo fotoUrl existe en el JSON request
            if (StringUtils.hasText(request.getFotoUrl())) {
                user.setFotoUrl(request.getFotoUrl());
            } else {
                user.setFotoUrl(null);
            }
        }
        User updatedUser = userRepository.save(user);
        return userMapper.userToUserResponse(updatedUser);
    }
    @Override
    @Transactional
    public void deleteUserProfile(String userEmail) {
        User user = userRepository.findByEmail(userEmail)
                .orElseThrow(() -> new ResourceNotFoundException("Usuario no encontrado con email: " + userEmail + ". No se puede eliminar."));
        userRepository.delete(user);
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\main\java\tutorgo\com\utils\AppConstants.java
package tutorgo.com.utils;
public class AppConstants {
    public static final String DEFAULT_PAGE_NUMBER = "0";
    public static final String DEFAULT_PAGE_SIZE = "10";
    public static final String DEFAULT_SORT_BY_USER = "id";
    public static final String DEFAULT_SORT_BY_TUTOR = "id";
    public static final String DEFAULT_SORT_DIRECTION = "asc";
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\test\java\tutorgo\com\TutorgoApplicationTests.java
package tutorgo.com;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
@SpringBootTest
class TutorgoApplicationTests {
    @Test
    void contextLoads() {
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\test\java\tutorgo\com\service\AuthServiceImplTest.java
package tutorgo.com.service;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import tutorgo.com.dto.request.LoginRequest;
import tutorgo.com.dto.response.JwtAuthenticationResponse;
import tutorgo.com.dto.response.UserResponse;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.mapper.UserMapper;
import tutorgo.com.model.Role;
import tutorgo.com.model.User;
import tutorgo.com.repository.UserRepository;
import tutorgo.com.security.JwtTokenProvider;
import tutorgo.com.enums.RoleName;
import java.util.Collections;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;
@ExtendWith(MockitoExtension.class)
class AuthServiceImplTest {
    @Mock
    private AuthenticationManager authenticationManager;
    @Mock
    private JwtTokenProvider jwtTokenProvider;
    @Mock
    private UserRepository userRepository;
    @Mock
    private UserMapper userMapper;
    @InjectMocks
    private AuthServiceImpl authService;
    private LoginRequest loginRequest;
    private User user;
    private UserResponse userResponse;
    private Authentication authentication;
    @BeforeEach
    void setUp() {
        loginRequest = new LoginRequest();
        loginRequest.setEmail("test@example.com");
        loginRequest.setPassword("password123");
        Role role = new Role(1, RoleName.ESTUDIANTE);
        user = User.builder()
                .id(1L)
                .email("test@example.com")
                .password("encodedPassword") // Simula la contraseña hasheada
                .role(role)
                .nombre("Test User")
                .build();
        userResponse = new UserResponse(); // Simula la respuesta del mapper
        userResponse.setId(1L);
        userResponse.setEmail("test@example.com");
        userResponse.setRol(RoleName.ESTUDIANTE);
        authentication = mock(Authentication.class); // Mock de la interfaz Authentication
    }
    @Test
    void loginUser_Success() {
        when(userRepository.findByEmail(loginRequest.getEmail())).thenReturn(Optional.of(user));
        Authentication successfulAuthentication = new UsernamePasswordAuthenticationToken(
                user.getEmail(), // Principal
                null,            // Credentials (no relevantes para la generación del token aquí)
                Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + user.getRole().getNombre().name())) // Authorities
        );
        when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class)))
                .thenReturn(successfulAuthentication);
        when(jwtTokenProvider.generateToken(successfulAuthentication)).thenReturn("mocked.jwt.token");
        when(userMapper.userToUserResponse(user)).thenReturn(userResponse);
        JwtAuthenticationResponse result = authService.loginUser(loginRequest);
        assertNotNull(result);
        assertEquals("mocked.jwt.token", result.getAccessToken());
        assertEquals(userResponse, result.getUser());
        verify(authenticationManager).authenticate(any(UsernamePasswordAuthenticationToken.class));
        verify(jwtTokenProvider).generateToken(successfulAuthentication);
        verify(userMapper).userToUserResponse(user);
    }
    @Test
    void loginUser_InvalidCredentials_ThrowsBadCredentialsException() {
        when(userRepository.findByEmail(loginRequest.getEmail())).thenReturn(Optional.of(user));
        when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class)))
                .thenThrow(new BadCredentialsException("Credenciales inválidas"));
        BadCredentialsException exception = assertThrows(BadCredentialsException.class, () -> {
            authService.loginUser(loginRequest);
        });
        assertEquals("Credenciales inválidas. Pruebe de nuevo.", exception.getMessage());
    }
    @Test
    void loginUser_UserNotFound_ThrowsResourceNotFoundException() {
        when(userRepository.findByEmail(loginRequest.getEmail())).thenReturn(Optional.empty());
        ResourceNotFoundException exception = assertThrows(ResourceNotFoundException.class, () -> {
            authService.loginUser(loginRequest);
        });
        assertEquals("Correo no registrado. Regístrese.", exception.getMessage());
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\test\java\tutorgo\com\service\DisponibilidadServiceImplTest.java
package tutorgo.com.service;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import tutorgo.com.dto.request.DisponibilidadRequest;
import tutorgo.com.dto.response.DisponibilidadResponse;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.exception.ForbiddenException;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.mapper.DisponibilidadMapper;
import tutorgo.com.model.Disponibilidad;
import tutorgo.com.model.Tutor;
import tutorgo.com.model.User;
import tutorgo.com.repository.DisponibilidadRepository;
import tutorgo.com.repository.SesionRepository;
import tutorgo.com.repository.TutorRepository;
import tutorgo.com.repository.UserRepository;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.*;
@ExtendWith(MockitoExtension.class)
class DisponibilidadServiceImplTest {
    @Mock private UserRepository userRepository;
    @Mock private TutorRepository tutorRepository;
    @Mock private DisponibilidadRepository disponibilidadRepository;
    @Mock private SesionRepository sesionRepository;
    @Mock private DisponibilidadMapper disponibilidadMapper;
    @InjectMocks private DisponibilidadServiceImpl disponibilidadService;
    private User mockUserTutor;
    private Tutor mockTutor;
    private DisponibilidadRequest disponibilidadRequest;
    private String tutorEmail = "tutor@example.com";
    @BeforeEach
    void setUp() {
        mockUserTutor = User.builder().id(1L).email(tutorEmail).build();
        mockTutor = Tutor.builder().id(1L).user(mockUserTutor).build();
        disponibilidadRequest = new DisponibilidadRequest();
        disponibilidadRequest.setFecha(LocalDate.now().plusDays(1));
        disponibilidadRequest.setHoraInicio(LocalTime.of(9, 0));
        disponibilidadRequest.setHoraFinal(LocalTime.of(12, 0));
    }
    @Test
    void addDisponibilidad_Success() {
        Disponibilidad nuevaDisp = new Disponibilidad(); // Simular lo que se guardaría
        DisponibilidadResponse mockResponse = new DisponibilidadResponse(); // Simular lo que el mapper devolvería
        when(userRepository.findByEmail(tutorEmail)).thenReturn(Optional.of(mockUserTutor));
        when(tutorRepository.findByUser(mockUserTutor)).thenReturn(Optional.of(mockTutor));
        when(disponibilidadRepository.findDisponibilidadesSolapadas(anyLong(), any(LocalDate.class), any(LocalDateTime.class), any(LocalDateTime.class)))
                .thenReturn(Collections.emptyList());
        when(disponibilidadRepository.save(any(Disponibilidad.class))).thenReturn(nuevaDisp);
        when(disponibilidadMapper.toDisponibilidadResponse(nuevaDisp)).thenReturn(mockResponse);
        DisponibilidadResponse result = disponibilidadService.addDisponibilidad(tutorEmail, disponibilidadRequest);
        assertNotNull(result);
        verify(disponibilidadRepository).save(any(Disponibilidad.class));
    }
    @Test
    void addDisponibilidad_HoraFinalAntesDeInicial_ThrowsBadRequestException() {
        disponibilidadRequest.setHoraFinal(LocalTime.of(8, 0)); // Error: 08:00 es antes de 09:00
        when(userRepository.findByEmail(tutorEmail)).thenReturn(Optional.of(mockUserTutor));
        when(tutorRepository.findByUser(mockUserTutor)).thenReturn(Optional.of(mockTutor));
        BadRequestException ex = assertThrows(BadRequestException.class, () -> {
            disponibilidadService.addDisponibilidad(tutorEmail, disponibilidadRequest);
        });
        assertEquals("La hora de finalización debe ser posterior a la hora de inicio.", ex.getMessage());
    }
    @Test
    void addDisponibilidad_Solapamiento_ThrowsBadRequestException() {
        Disponibilidad dispExistente = new Disponibilidad(); // Simular una disp que se solapa
        when(userRepository.findByEmail(tutorEmail)).thenReturn(Optional.of(mockUserTutor));
        when(tutorRepository.findByUser(mockUserTutor)).thenReturn(Optional.of(mockTutor));
        when(disponibilidadRepository.findDisponibilidadesSolapadas(anyLong(), any(LocalDate.class), any(LocalDateTime.class), any(LocalDateTime.class)))
                .thenReturn(List.of(dispExistente));
        BadRequestException ex = assertThrows(BadRequestException.class, () -> {
            disponibilidadService.addDisponibilidad(tutorEmail, disponibilidadRequest);
        });
        assertEquals("La nueva disponibilidad se solapa con una existente.", ex.getMessage());
    }
    @Test
    void updateDisponibilidad_Success() {
        Long disponibilidadId = 1L;
        Disponibilidad existente = Disponibilidad.builder().id(disponibilidadId).tutor(mockTutor)
                .fecha(LocalDate.now().plusDays(1))
                .horaInicial(LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(10,0)))
                .horaFinal(LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(11,0)))
                .build();
        DisponibilidadResponse mockResponse = new DisponibilidadResponse(); // Llenar datos
        when(userRepository.findByEmail(tutorEmail)).thenReturn(Optional.of(mockUserTutor));
        when(tutorRepository.findByUser(mockUserTutor)).thenReturn(Optional.of(mockTutor));
        when(disponibilidadRepository.findById(disponibilidadId)).thenReturn(Optional.of(existente));
        when(sesionRepository.countSesionesActivasEnRango(anyLong(), any(), any(), any())).thenReturn(0L); // No hay sesiones
        when(disponibilidadRepository.findDisponibilidadesSolapadasExcluyendoActual(anyLong(), any(), any(), any(), eq(disponibilidadId)))
                .thenReturn(Collections.emptyList()); // No hay solapamiento
        when(disponibilidadRepository.save(any(Disponibilidad.class))).thenReturn(existente); // Simula el guardado
        when(disponibilidadMapper.toDisponibilidadResponse(existente)).thenReturn(mockResponse);
        DisponibilidadResponse result = disponibilidadService.updateDisponibilidad(tutorEmail, disponibilidadId, disponibilidadRequest);
        assertNotNull(result);
        verify(disponibilidadRepository).save(existente);
    }
    @Test
    void updateDisponibilidad_HasActiveSessions_ThrowsBadRequestException() {
        Long disponibilidadId = 1L;
        Disponibilidad existente = Disponibilidad.builder().id(disponibilidadId).tutor(mockTutor)
                .fecha(LocalDate.now().plusDays(1))
                .horaInicial(LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(10,0)))
                .horaFinal(LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(11,0)))
                .build();
        when(userRepository.findByEmail(tutorEmail)).thenReturn(Optional.of(mockUserTutor));
        when(tutorRepository.findByUser(mockUserTutor)).thenReturn(Optional.of(mockTutor));
        when(disponibilidadRepository.findById(disponibilidadId)).thenReturn(Optional.of(existente));
        when(sesionRepository.countSesionesActivasEnRango(anyLong(), any(), any(), any())).thenReturn(1L); // Hay sesiones
        BadRequestException ex = assertThrows(BadRequestException.class, () -> {
            disponibilidadService.updateDisponibilidad(tutorEmail, disponibilidadId, disponibilidadRequest);
        });
        assertEquals("No se puede modificar la disponibilidad porque ya tiene sesiones reservadas o confirmadas en este horario.", ex.getMessage());
    }
    @Test
    void deleteDisponibilidad_Success() {
        Long disponibilidadId = 1L;
        Disponibilidad existente = Disponibilidad.builder().id(disponibilidadId).tutor(mockTutor).build();
        when(userRepository.findByEmail(tutorEmail)).thenReturn(Optional.of(mockUserTutor));
        when(tutorRepository.findByUser(mockUserTutor)).thenReturn(Optional.of(mockTutor));
        when(disponibilidadRepository.findById(disponibilidadId)).thenReturn(Optional.of(existente));
        when(sesionRepository.countSesionesActivasEnRango(anyLong(), any(), any(), any())).thenReturn(0L);
        assertDoesNotThrow(() -> disponibilidadService.deleteDisponibilidad(tutorEmail, disponibilidadId));
        verify(disponibilidadRepository).delete(existente);
    }
    @Test
    void deleteDisponibilidad_NotOwner_ThrowsForbiddenException() {
        Long disponibilidadId = 1L;
        Tutor otroTutor = Tutor.builder().id(99L).build(); // Un tutor diferente
        Disponibilidad existente = Disponibilidad.builder().id(disponibilidadId).tutor(otroTutor).build();
        when(userRepository.findByEmail(tutorEmail)).thenReturn(Optional.of(mockUserTutor));
        when(tutorRepository.findByUser(mockUserTutor)).thenReturn(Optional.of(mockTutor)); // mockTutor tiene ID 1L
        when(disponibilidadRepository.findById(disponibilidadId)).thenReturn(Optional.of(existente));
        assertThrows(ForbiddenException.class, () -> {
            disponibilidadService.deleteDisponibilidad(tutorEmail, disponibilidadId);
        });
    }
    @Test
    void getDisponibilidadesByTutorId_whenTutorExists_shouldReturnDisponibilidades() {
        Long tutorId = 1L;
        Disponibilidad disp1 = new Disponibilidad(1L, mockTutor, LocalDate.now(), LocalDateTime.now(), LocalDateTime.now().plusHours(1));
        List<Disponibilidad> disponibilidades = List.of(disp1);
        DisponibilidadResponse resp1 = new DisponibilidadResponse();
        resp1.setId(1L);
        when(tutorRepository.findById(tutorId)).thenReturn(Optional.of(mockTutor));
        when(disponibilidadRepository.findByTutorOrderByFechaAscHoraInicialAsc(mockTutor)).thenReturn(disponibilidades);
        when(disponibilidadMapper.toDisponibilidadResponseList(disponibilidades)).thenReturn(List.of(resp1));
        List<DisponibilidadResponse> result = disponibilidadService.getDisponibilidadesByTutorId(tutorId);
        assertNotNull(result);
        assertFalse(result.isEmpty());
        assertEquals(1, result.size());
        verify(tutorRepository).findById(tutorId);
        verify(disponibilidadRepository).findByTutorOrderByFechaAscHoraInicialAsc(mockTutor);
        verify(disponibilidadMapper).toDisponibilidadResponseList(disponibilidades);
    }
    @Test
    void getDisponibilidadesByTutorId_whenTutorDoesNotExist_shouldThrowResourceNotFoundException() {
        Long tutorId = 99L;
        when(tutorRepository.findById(tutorId)).thenReturn(Optional.empty());
        assertThrows(ResourceNotFoundException.class, () -> {
            disponibilidadService.getDisponibilidadesByTutorId(tutorId);
        });
        verify(disponibilidadRepository, never()).findByTutorOrderByFechaAscHoraInicialAsc(any());
        verify(disponibilidadMapper, never()).toDisponibilidadResponseList(any());
    }
    @Test
    void getDisponibilidadesByTutorId_whenTutorHasNoDisponibilidades_shouldReturnEmptyList() {
        Long tutorId = 1L;
        when(tutorRepository.findById(tutorId)).thenReturn(Optional.of(mockTutor));
        when(disponibilidadRepository.findByTutorOrderByFechaAscHoraInicialAsc(mockTutor)).thenReturn(Collections.emptyList());
        when(disponibilidadMapper.toDisponibilidadResponseList(Collections.emptyList())).thenReturn(Collections.emptyList());
        List<DisponibilidadResponse> result = disponibilidadService.getDisponibilidadesByTutorId(tutorId);
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\test\java\tutorgo\com\service\EnlaceSesionServiceImplTest.java
package tutorgo.com.service;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.security.access.AccessDeniedException;
import tutorgo.com.dto.request.EnlaceSesionRequestDTO;
import tutorgo.com.dto.response.EnlaceSesionResponseDTO;
import tutorgo.com.mapper.EnlaceSesionMapper;
import tutorgo.com.model.*;
import tutorgo.com.repository.EnlaceSesionRepository;
import tutorgo.com.repository.SesionRepository;
import java.util.*;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
class EnlaceSesionServiceImplTest {
    @InjectMocks
    private EnlaceSesionServiceImpl service;
    @Mock
    private EnlaceSesionRepository enlaceSesionRepository;
    @Mock
    private SesionRepository sesionRepository;
    @Mock
    private EnlaceSesionMapper enlaceSesionMapper;
    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }
    @Test
    void guardarEnlaces_Correctamente() {
        Long sesionId = 1L;
        String emailTutor = "tutor@example.com";
        EnlaceSesionRequestDTO requestDTO = new EnlaceSesionRequestDTO();
        requestDTO.setNombre("Zoom");
        requestDTO.setEnlace("http://zoom.com");
        User tutorUser = new User();
        tutorUser.setEmail(emailTutor);
        Tutor tutor = new Tutor();
        tutor.setUser(tutorUser);
        Sesion sesion = new Sesion();
        sesion.setId(sesionId);
        sesion.setTutor(tutor);
        sesion.setEnlaces(new ArrayList<>());  // Enlaces actuales = 0
        EnlaceSesion entity = new EnlaceSesion();
        entity.setNombre("Zoom");
        entity.setEnlace("http://zoom.com");
        entity.setSesion(sesion);
        EnlaceSesionResponseDTO responseDTO = new EnlaceSesionResponseDTO();
        responseDTO.setId(1L);
        responseDTO.setNombre("Zoom");
        responseDTO.setEnlace("http://zoom.com");
        when(sesionRepository.findById(sesionId)).thenReturn(Optional.of(sesion));
        when(enlaceSesionRepository.saveAll(anyList())).thenReturn(List.of(entity));
        when(enlaceSesionMapper.toResponseDTO(any(EnlaceSesion.class))).thenReturn(responseDTO);
        List<EnlaceSesionResponseDTO> result = service.guardarEnlaces(
                sesionId, List.of(requestDTO), emailTutor
        );
        assertEquals(1, result.size());
        assertEquals("Zoom", result.get(0).getNombre());
        verify(enlaceSesionRepository).saveAll(anyList());
    }
    @Test
    void guardarEnlaces_MasDe5_DeberiaFallar() {
        Long sesionId = 1L;
        String emailTutor = "tutor@example.com";
        User user = new User();
        user.setEmail(emailTutor);
        Tutor tutor = new Tutor();
        tutor.setUser(user);
        Sesion sesion = new Sesion();
        sesion.setId(sesionId);
        sesion.setTutor(tutor);
        List<EnlaceSesion> enlacesActuales = new ArrayList<>(Collections.nCopies(5, new EnlaceSesion()));
        sesion.setEnlaces(enlacesActuales);  // ya hay 5
        when(sesionRepository.findById(sesionId)).thenReturn(Optional.of(sesion));
        EnlaceSesionRequestDTO nuevoEnlace = new EnlaceSesionRequestDTO();
        nuevoEnlace.setNombre("Nuevo");
        nuevoEnlace.setEnlace("http://nuevo.com");
        assertThrows(IllegalStateException.class, () ->
                service.guardarEnlaces(sesionId, List.of(nuevoEnlace), emailTutor));
    }
    @Test
    void guardarEnlaces_EmailTutorNoCoincide_DeberiaFallar() {
        Long sesionId = 1L;
        String emailTutor = "otro@example.com"; // no es el dueño
        User user = new User();
        user.setEmail("tutor@example.com");
        Tutor tutor = new Tutor();
        tutor.setUser(user);
        Sesion sesion = new Sesion();
        sesion.setId(sesionId);
        sesion.setTutor(tutor);
        when(sesionRepository.findById(sesionId)).thenReturn(Optional.of(sesion));
        EnlaceSesionRequestDTO dto = new EnlaceSesionRequestDTO();
        dto.setNombre("Zoom");
        dto.setEnlace("http://zoom.com");
        assertThrows(AccessDeniedException.class, () ->
                service.guardarEnlaces(sesionId, List.of(dto), emailTutor));
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\test\java\tutorgo\com\service\NotificacionServiceImplTest.java
package tutorgo.com.service;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import tutorgo.com.dto.response.NotificacionResponse;
import tutorgo.com.enums.RoleName;
import tutorgo.com.enums.TipoNotificacionEstEnum;
import tutorgo.com.enums.TipoNotificacionTutorEnum;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.model.*;
import tutorgo.com.repository.NotificacionEstudianteRepository;
import tutorgo.com.repository.NotificacionTutorRepository;
import tutorgo.com.repository.UserRepository;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
@ExtendWith(MockitoExtension.class)
@DisplayName("Pruebas Unitarias para NotificacionServiceImpl")
class NotificacionServiceImplTest {
    @Mock
    private UserRepository userRepository;
    @Mock
    private NotificacionEstudianteRepository notificacionEstudianteRepository;
    @Mock
    private NotificacionTutorRepository notificacionTutorRepository;
    @InjectMocks
    private NotificacionServiceImpl notificacionService;
    private User mockUserEstudiante;
    private User mockUserTutor;
    private Estudiante mockEstudiante;
    private Tutor mockTutor;
    @BeforeEach
    void setUp() {
        Role roleEstudiante = new Role(3, RoleName.ESTUDIANTE);
        mockUserEstudiante = User.builder().id(1L).email("estudiante@test.com").role(roleEstudiante).build();
        mockEstudiante = Estudiante.builder().id(1L).user(mockUserEstudiante).build();
        mockUserEstudiante.setStudentProfile(mockEstudiante);
        Role roleTutor = new Role(2, RoleName.TUTOR);
        mockUserTutor = User.builder().id(2L).email("tutor@test.com").role(roleTutor).build();
        mockTutor = Tutor.builder().id(1L).user(mockUserTutor).build();
        mockUserTutor.setTutorProfile(mockTutor);
    }
    @Nested
    @DisplayName("Pruebas para getMisNotificaciones")
    class GetMisNotificacionesTests {
        @Test
        @DisplayName("Debe devolver las notificaciones de un estudiante si el rol es ESTUDIANTE")
        void getMisNotificaciones_whenUserIsEstudiante_shouldReturnEstudianteNotifications() {
            String emailEstudiante = "estudiante@test.com";
            NotificacionEstudiante notificacion = new NotificacionEstudiante();
            notificacion.setId(1L);
            notificacion.setTitulo("Recordatorio");
            notificacion.setTexto("Tu clase es mañana.");
            notificacion.setFechaCreacion(LocalDateTime.now());
            notificacion.setTipo(TipoNotificacionEstEnum.RECORDATORIO);
            when(userRepository.findByEmail(emailEstudiante)).thenReturn(Optional.of(mockUserEstudiante));
            when(notificacionEstudianteRepository.findByEstudianteOrderByFechaCreacionDesc(mockEstudiante))
                    .thenReturn(List.of(notificacion));
            List<NotificacionResponse> result = notificacionService.getMisNotificaciones(emailEstudiante);
            assertNotNull(result);
            assertEquals(1, result.size());
            assertEquals("Recordatorio", result.get(0).getTitulo());
            assertEquals("RECORDATORIO", result.get(0).getTipo()); // Verificar que el tipo se mapea a String
        }
        @Test
        @DisplayName("Debe devolver las notificaciones de un tutor si el rol es TUTOR")
        void getMisNotificaciones_whenUserIsTutor_shouldReturnTutorNotifications() {
            String emailTutor = "tutor@test.com";
            NotificacionTutor notificacion = new NotificacionTutor();
            notificacion.setId(1L);
            notificacion.setTitulo("Nueva Reserva");
            notificacion.setTexto("Un alumno ha reservado una clase.");
            notificacion.setFechaCreacion(LocalDateTime.now());
            notificacion.setTipo(TipoNotificacionTutorEnum.RESERVA);
            when(userRepository.findByEmail(emailTutor)).thenReturn(Optional.of(mockUserTutor));
            when(notificacionTutorRepository.findByTutorOrderByFechaCreacionDesc(mockTutor))
                    .thenReturn(List.of(notificacion));
            List<NotificacionResponse> result = notificacionService.getMisNotificaciones(emailTutor);
            assertNotNull(result);
            assertEquals(1, result.size());
            assertEquals("Nueva Reserva", result.get(0).getTitulo());
            assertEquals("RESERVA", result.get(0).getTipo()); // Verificar
        }
        @Test
        @DisplayName("Debe devolver una lista vacía si el usuario no tiene notificaciones")
        void getMisNotificaciones_whenUserHasNoNotifications_shouldReturnEmptyList() {
            String emailEstudiante = "estudiante@test.com";
            when(userRepository.findByEmail(emailEstudiante)).thenReturn(Optional.of(mockUserEstudiante));
            when(notificacionEstudianteRepository.findByEstudianteOrderByFechaCreacionDesc(mockEstudiante))
                    .thenReturn(Collections.emptyList());
            List<NotificacionResponse> result = notificacionService.getMisNotificaciones(emailEstudiante);
            assertNotNull(result);
            assertTrue(result.isEmpty());
        }
        @Test
        @DisplayName("Debe lanzar ResourceNotFoundException si el usuario no existe")
        void getMisNotificaciones_whenUserNotFound_shouldThrowException() {
            String nonExistentEmail = "noexiste@test.com";
            when(userRepository.findByEmail(nonExistentEmail)).thenReturn(Optional.empty());
            assertThrows(ResourceNotFoundException.class, () -> {
                notificacionService.getMisNotificaciones(nonExistentEmail);
            });
        }
        @Test
        @DisplayName("Debe devolver una lista vacía si el usuario no tiene perfil de estudiante o tutor")
        void getMisNotificaciones_whenUserHasNoProfile_shouldReturnEmptyList() {
            String emailSinPerfil = "sinperfil@test.com";
            User userSinPerfil = User.builder().id(3L).email(emailSinPerfil).role(new Role(3, RoleName.ESTUDIANTE)).build();
            when(userRepository.findByEmail(emailSinPerfil)).thenReturn(Optional.of(userSinPerfil));
            List<NotificacionResponse> result = notificacionService.getMisNotificaciones(emailSinPerfil);
            assertNotNull(result);
            assertTrue(result.isEmpty());
        }
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\test\java\tutorgo\com\service\PagoServiceImplTest.java
package tutorgo.com.service;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import tutorgo.com.dto.request.ConfirmarPagoRequest;
import tutorgo.com.dto.response.PagoResponse;
import tutorgo.com.enums.EstadoPagoEnum;
import tutorgo.com.enums.EstadoSesionEnum;
import tutorgo.com.enums.MetodoPagoEnum;
import tutorgo.com.enums.RoleName;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.exception.ForbiddenException;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.mapper.PagoMapper;
import tutorgo.com.model.*;
import tutorgo.com.repository.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.*;
@ExtendWith(MockitoExtension.class)
@DisplayName("Pruebas Unitarias para PagoServiceImpl")
class PagoServiceImplTest {
    @Mock private UserRepository userRepository;
    @Mock private EstudianteRepository estudianteRepository;
    @Mock private SesionRepository sesionRepository;
    @Mock private PagoRepository pagoRepository;
    @Mock private DisponibilidadRepository disponibilidadRepository;
    @Mock private PagoMapper pagoMapper;
    @InjectMocks
    private PagoServiceImpl pagoService;
    private User mockUserAlumno;
    private Estudiante mockAlumno;
    private Tutor mockTutor;
    private Sesion mockSesionPendiente;
    private ConfirmarPagoRequest confirmarPagoRequest;
    private final String alumnoEmail = "alumno.pago@example.com";
    private final Long sesionId = 1L;
    @BeforeEach
    void setUp() {
        mockUserAlumno = User.builder().id(1L).email(alumnoEmail).role(new Role(3, null)).build();
        mockAlumno = Estudiante.builder().id(1L).user(mockUserAlumno).build();
        mockTutor = Tutor.builder().id(1L).tarifaHora(60).user(User.builder().id(2L).build()).build();
        mockSesionPendiente = Sesion.builder()
                .id(sesionId)
                .estudiante(mockAlumno)
                .tutor(mockTutor)
                .fecha(LocalDate.now().plusDays(1))
                .horaInicial(LocalDateTime.now().plusDays(1).withHour(10).withMinute(0).withSecond(0).withNano(0))
                .horaFinal(LocalDateTime.now().plusDays(1).withHour(11).withMinute(0).withSecond(0).withNano(0)) // 1 hora
                .tipoEstado(EstadoSesionEnum.PENDIENTE)
                .build();
        mockUserAlumno.setStudentProfile(mockAlumno); // Asegurar la relación bidireccional
        confirmarPagoRequest = new ConfirmarPagoRequest();
        confirmarPagoRequest.setSesionId(sesionId);
        confirmarPagoRequest.setMetodoPago(MetodoPagoEnum.TARJETA_CREDITO);
    }
    @Nested
    @DisplayName("Pruebas para procesarPagoYConfirmarSesion (HU10)")
    class ProcesarPagoTests {
        @Test
        @DisplayName("Debe procesar el pago, confirmar la sesión y dividir la disponibilidad correctamente")
        void procesarPagoYConfirmarSesion_whenSuccess_shouldUpdateEntitiesAndReturnResponse() {
            Pago mockPagoGuardado = new Pago();
            PagoResponse mockPagoResponse = new PagoResponse();
            Disponibilidad disponibilidadOriginalParaMock = Disponibilidad.builder()
                    .id(12L)
                    .tutor(mockTutor)
                    .fecha(mockSesionPendiente.getFecha())
                    .horaInicial(LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(9, 0)))  // 09:00
                    .horaFinal(LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(12, 0))) // 12:00
                    .build();
            when(userRepository.findByEmail(alumnoEmail)).thenReturn(Optional.of(mockUserAlumno));
            when(estudianteRepository.findByUser(mockUserAlumno)).thenReturn(Optional.of(mockAlumno));
            when(sesionRepository.findById(sesionId)).thenReturn(Optional.of(mockSesionPendiente));
            when(pagoRepository.save(any(Pago.class))).thenReturn(mockPagoGuardado);
            when(pagoMapper.toPagoResponse(mockPagoGuardado)).thenReturn(mockPagoResponse);
            when(disponibilidadRepository.findDisponibilidadQueEnvuelveElSlot(anyLong(), any(), any(), any()))
                    .thenReturn(List.of(disponibilidadOriginalParaMock));
            pagoService.procesarPagoYConfirmarSesion(alumnoEmail, confirmarPagoRequest);
            verify(pagoRepository).save(any(Pago.class));
            verify(sesionRepository).save(argThat(sesion -> sesion.getTipoEstado() == EstadoSesionEnum.CONFIRMADO));
            ArgumentCaptor<Disponibilidad> disponibilidadCaptor = ArgumentCaptor.forClass(Disponibilidad.class);
            verify(disponibilidadRepository, times(2)).save(disponibilidadCaptor.capture());
            List<Disponibilidad> disponibilidadesGuardadas = disponibilidadCaptor.getAllValues();
            Disponibilidad primerBloqueGuardado = disponibilidadesGuardadas.get(0);
            Disponibilidad segundoBloqueGuardado = disponibilidadesGuardadas.get(1);
            assertEquals(12L, primerBloqueGuardado.getId(), "El ID del primer bloque debe ser el original.");
            assertEquals(
                    disponibilidadOriginalParaMock.getHoraInicial(), // 09:00
                    primerBloqueGuardado.getHoraInicial(),
                    "La hora de inicio del primer bloque debe ser la original."
            );
            assertEquals(
                    mockSesionPendiente.getHoraInicial(), // 10:00
                    primerBloqueGuardado.getHoraFinal(),
                    "La hora final del primer bloque debe ser la hora de inicio de la sesión."
            );
            assertEquals(
                    mockSesionPendiente.getHoraFinal(), // 11:00
                    segundoBloqueGuardado.getHoraInicial(),
                    "La hora de inicio del segundo bloque debe ser la hora final de la sesión."
            );
            assertEquals(
                    disponibilidadOriginalParaMock.getHoraFinal(), // 12:00
                    segundoBloqueGuardado.getHoraFinal(),
                    "La hora final del segundo bloque debe ser la hora final del bloque original."
            );
        }
        @Test
        @DisplayName("Debe lanzar BadRequestException si la sesión no está pendiente")
        void procesarPagoYConfirmarSesion_whenSesionNotPendiente_shouldThrowBadRequest() {
            mockSesionPendiente.setTipoEstado(EstadoSesionEnum.CONFIRMADO);
            when(userRepository.findByEmail(alumnoEmail)).thenReturn(Optional.of(mockUserAlumno));
            when(estudianteRepository.findByUser(mockUserAlumno)).thenReturn(Optional.of(mockAlumno));
            when(sesionRepository.findById(sesionId)).thenReturn(Optional.of(mockSesionPendiente));
            assertThrows(BadRequestException.class, () ->
                    pagoService.procesarPagoYConfirmarSesion(alumnoEmail, confirmarPagoRequest)
            );
        }
        @Test
        @DisplayName("Debe lanzar ForbiddenException si la sesión no pertenece al alumno")
        void procesarPagoYConfirmarSesion_whenSesionBelongsToOther_shouldThrowForbidden() {
            Estudiante otroAlumno = Estudiante.builder().id(99L).user(new User()).build();
            mockSesionPendiente.setEstudiante(otroAlumno);
            when(userRepository.findByEmail(alumnoEmail)).thenReturn(Optional.of(mockUserAlumno));
            when(estudianteRepository.findByUser(mockUserAlumno)).thenReturn(Optional.of(mockAlumno));
            when(sesionRepository.findById(sesionId)).thenReturn(Optional.of(mockSesionPendiente));
            assertThrows(ForbiddenException.class, () ->
                    pagoService.procesarPagoYConfirmarSesion(alumnoEmail, confirmarPagoRequest)
            );
        }
    }
    @Nested
    @DisplayName("Pruebas para obtenerHistorialTransacciones (HU15)")
    class GetHistorialTests {
        @Test
        @DisplayName("Debe devolver el historial de un estudiante")
        void obtenerHistorialTransacciones_forEstudiante_shouldSucceed() {
            when(userRepository.findByEmail(alumnoEmail)).thenReturn(Optional.of(mockUserAlumno));
            when(pagoRepository.findByEstudianteIdWithDetails(mockAlumno.getId())).thenReturn(Collections.emptyList());
            List<PagoResponse> result = pagoService.obtenerHistorialTransacciones(alumnoEmail);
            assertNotNull(result);
            assertTrue(result.isEmpty());
            verify(pagoRepository).findByEstudianteIdWithDetails(mockAlumno.getId());
            verify(pagoRepository, never()).findByTutorIdWithDetails(anyLong());
        }
        @Test
        @DisplayName("Debe devolver el historial de un tutor")
        void obtenerHistorialTransacciones_forTutor_shouldSucceed() {
            String emailTutor = "tutor.pago@example.com";
            User mockUserTutor = User.builder().id(2L).email(emailTutor).role(new Role(2, RoleName.TUTOR)).build();
            Tutor mockTutorHistorial = Tutor.builder().id(2L).user(mockUserTutor).build();
            mockUserTutor.setTutorProfile(mockTutorHistorial);
            when(userRepository.findByEmail(emailTutor)).thenReturn(Optional.of(mockUserTutor));
            when(pagoRepository.findByTutorIdWithDetails(mockTutorHistorial.getId())).thenReturn(Collections.emptyList());
            List<PagoResponse> result = pagoService.obtenerHistorialTransacciones(emailTutor);
            assertNotNull(result);
            assertTrue(result.isEmpty());
            verify(pagoRepository).findByTutorIdWithDetails(mockTutorHistorial.getId());
            verify(pagoRepository, never()).findByEstudianteIdWithDetails(anyLong());
        }
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\test\java\tutorgo\com\service\ResenaServiceImplTest.java
package tutorgo.com.service;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import tutorgo.com.dto.request.ResenaRequestDTO;
import tutorgo.com.dto.response.ResenaResponseDTO;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.mapper.ResenaMapper;
import tutorgo.com.model.*;
import tutorgo.com.repository.ResenaRepository;
import tutorgo.com.repository.SesionRepository;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
public class ResenaServiceImplTest {
    @InjectMocks
    private ResenaServiceImpl resenaService;
    @Mock
    private ResenaRepository resenaRepository;
    @Mock
    private SesionRepository sesionRepository;
    @Mock
    private ResenaMapper resenaMapper;
    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }
    @Test
    void crearResena_Exitosa() {
        Long sesionId = 1L;
        String emailEstudiante = "estudiante@example.com";
        ResenaRequestDTO requestDTO = new ResenaRequestDTO();
        requestDTO.setCalificacion(5);
        requestDTO.setComentario("Excelente sesión");
        User user = new User();
        user.setEmail(emailEstudiante);
        Estudiante estudiante = new Estudiante();
        estudiante.setUser(user);
        Sesion sesion = new Sesion();
        sesion.setId(sesionId);
        sesion.setEstudiante(estudiante);
        Resena resena = new Resena();
        resena.setCalificacion(5);
        resena.setComentario("Excelente sesión");
        resena.setSesion(sesion);
        Resena resenaGuardada = new Resena();
        resenaGuardada.setId(10L);
        resenaGuardada.setCalificacion(5);
        resenaGuardada.setComentario("Excelente sesión");
        ResenaResponseDTO responseDTO = new ResenaResponseDTO();
        responseDTO.setId(10L);
        responseDTO.setCalificacion(5);
        responseDTO.setComentario("Excelente sesión");
        when(sesionRepository.findById(sesionId)).thenReturn(Optional.of(sesion));
        when(resenaRepository.existsBySesionId(sesionId)).thenReturn(false);
        when(resenaMapper.toEntity(requestDTO)).thenReturn(resena);
        when(resenaRepository.save(resena)).thenReturn(resenaGuardada);
        when(resenaMapper.toDTO(resenaGuardada)).thenReturn(responseDTO);
        ResenaResponseDTO resultado = resenaService.crearResena(sesionId, requestDTO, emailEstudiante);
        assertNotNull(resultado);
        assertEquals(10L, resultado.getId());
        assertEquals(5, resultado.getCalificacion());
        assertEquals("Excelente sesión", resultado.getComentario());
    }
    @Test
    void crearResena_LanzaException_SesionNoExiste() {
        when(sesionRepository.findById(99L)).thenReturn(Optional.empty());
        ResenaRequestDTO requestDTO = new ResenaRequestDTO();
        requestDTO.setCalificacion(4);
        assertThrows(ResourceNotFoundException.class,
                () -> resenaService.crearResena(99L, requestDTO, "email@fake.com"));
    }
    @Test
    void crearResena_LanzaException_CalificacionInvalida() {
        ResenaRequestDTO requestDTO = new ResenaRequestDTO();
        requestDTO.setCalificacion(6); // fuera de rango
        assertThrows(BadRequestException.class,
                () -> resenaService.crearResena(1L, requestDTO, "email@fake.com"));
    }
    @Test
    void crearResena_LanzaException_ComentarioLargo() {
        ResenaRequestDTO requestDTO = new ResenaRequestDTO();
        requestDTO.setCalificacion(4);
        requestDTO.setComentario("a".repeat(501)); // muy largo
        assertThrows(BadRequestException.class,
                () -> resenaService.crearResena(1L, requestDTO, "email@fake.com"));
    }
    @Test
    void crearResena_LanzaException_ResenaYaExiste() {
        Long sesionId = 1L;
        User user = new User();
        user.setEmail("student@example.com");
        Estudiante estudiante = new Estudiante();
        estudiante.setUser(user);
        Sesion sesion = new Sesion();
        sesion.setId(sesionId);
        sesion.setEstudiante(estudiante);
        when(sesionRepository.findById(sesionId)).thenReturn(Optional.of(sesion));
        when(resenaRepository.existsBySesionId(sesionId)).thenReturn(true);
        ResenaRequestDTO requestDTO = new ResenaRequestDTO();
        requestDTO.setCalificacion(4);
        assertThrows(BadRequestException.class,
                () -> resenaService.crearResena(sesionId, requestDTO, "student@example.com"));
    }
    @Test
    void crearResena_LanzaException_EmailNoCoincide() {
        Long sesionId = 1L;
        User user = new User();
        user.setEmail("otro@correo.com");
        Estudiante estudiante = new Estudiante();
        estudiante.setUser(user);
        Sesion sesion = new Sesion();
        sesion.setId(sesionId);
        sesion.setEstudiante(estudiante);
        when(sesionRepository.findById(sesionId)).thenReturn(Optional.of(sesion));
        when(resenaRepository.existsBySesionId(sesionId)).thenReturn(false);
        ResenaRequestDTO requestDTO = new ResenaRequestDTO();
        requestDTO.setCalificacion(5);
        assertThrows(BadRequestException.class,
                () -> resenaService.crearResena(sesionId, requestDTO, "student@example.com"));
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\test\java\tutorgo\com\service\SesionProgramadaServiceImplTest.java
package tutorgo.com.service;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import tutorgo.com.dto.response.SesionProgramadaResponseDTO;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.mapper.SesionProgramadaMapper;
import tutorgo.com.model.Estudiante;
import tutorgo.com.model.Sesion;
import tutorgo.com.model.User;
import tutorgo.com.repository.EstudianteRepository;
import tutorgo.com.repository.SesionRepository;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
public class SesionProgramadaServiceImplTest {
    private EstudianteRepository estudianteRepository;
    private SesionRepository sesionRepository;
    private SesionProgramadaMapper sesionProgramadaMapper;
    private SesionProgramadaServiceImpl sesionProgramadaService;
    @BeforeEach
    void setUp() {
        estudianteRepository = mock(EstudianteRepository.class);
        sesionRepository = mock(SesionRepository.class);
        sesionProgramadaMapper = mock(SesionProgramadaMapper.class);
        sesionProgramadaService = new SesionProgramadaServiceImpl(estudianteRepository, sesionRepository, sesionProgramadaMapper);
    }
    @Test
    void testObtenerSesionProgramadaDelEstudianteAutenticado_sesionExiste() {
        String email = "test@email.com";
        Estudiante estudiante = new Estudiante();
        estudiante.setId(1L);
        estudiante.setUser(User.builder().email(email).build());
        Sesion sesion = new Sesion();
        sesion.setHoraInicial(LocalDateTime.now().plusDays(1));
        estudiante.setSesionesComoEstudiante(List.of(sesion));
        SesionProgramadaResponseDTO dtoEsperado = new SesionProgramadaResponseDTO();
        dtoEsperado.setSesionId(1L);
        when(estudianteRepository.findByUserEmail(email)).thenReturn(Optional.of(estudiante));
        when(sesionProgramadaMapper.toResponseDTO(sesion)).thenReturn(dtoEsperado);
        SesionProgramadaResponseDTO result = sesionProgramadaService.obtenerSesionProgramadaDelEstudianteAutenticado(email);
        assertNotNull(result);
        assertEquals(dtoEsperado.getSesionId(), result.getSesionId());
    }
    @Test
    void testObtenerSesionProgramadaDelEstudianteAutenticado_sinSesiones() {
        String email = "test@email.com";
        Estudiante estudiante = new Estudiante();
        estudiante.setId(1L);
        estudiante.setUser(User.builder().email(email).build());
        estudiante.setSesionesComoEstudiante(List.of());
        when(estudianteRepository.findByUserEmail(email)).thenReturn(Optional.of(estudiante));
        SesionProgramadaResponseDTO result = sesionProgramadaService.obtenerSesionProgramadaDelEstudianteAutenticado(email);
        assertNotNull(result);
        assertNull(result.getSesionId());
        assertFalse(result.isEnlaceDisponible());
        assertEquals("No tienes sesiones programadas próximamente.", result.getMensaje());
    }
    @Test
    void testObtenerSesionProgramadaDelEstudianteAutenticado_estudianteNoExiste() {
        String email = "inexistente@email.com";
        when(estudianteRepository.findByUserEmail(email)).thenReturn(Optional.empty());
        assertThrows(BadRequestException.class, () -> {
            sesionProgramadaService.obtenerSesionProgramadaDelEstudianteAutenticado(email);
        });
    }
}

Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\test\java\tutorgo\com\service\SesionServiceImplTest.java
package tutorgo.com.service;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import tutorgo.com.dto.request.ReservaTutoriaRequest;
import tutorgo.com.dto.response.SesionResponse;
import tutorgo.com.enums.EstadoSesionEnum;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.mapper.SesionMapper;
import tutorgo.com.model.*;
import tutorgo.com.repository.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.*;
@ExtendWith(MockitoExtension.class)
@DisplayName("Pruebas Unitarias para SesionServiceImpl")
class SesionServiceImplTest {
    @Mock private EstudianteRepository estudianteRepository;
    @Mock private TutorRepository tutorRepository;
    @Mock private SesionRepository sesionRepository;
    @Mock private DisponibilidadRepository disponibilidadRepository;
    @Mock private SesionMapper sesionMapper;
    @InjectMocks
    private SesionServiceImpl sesionService;
    private Estudiante mockAlumno;
    private Tutor mockTutor;
    private ReservaTutoriaRequest reservaRequest;
    private final String alumnoEmail = "alumno@example.com";
    @BeforeEach
    void setUp() {
        User mockUserAlumno = User.builder().id(1L).email(alumnoEmail).build();
        mockAlumno = Estudiante.builder().id(1L).user(mockUserAlumno).build();
        User mockUserTutor = User.builder().id(2L).email("tutor@example.com").build();
        mockTutor = Tutor.builder().id(1L).user(mockUserTutor).build();
        reservaRequest = new ReservaTutoriaRequest();
        reservaRequest.setTutorId(mockTutor.getId());
        reservaRequest.setFecha(LocalDate.now().plusDays(2)); // Usar 2 días para evitar conflictos de zona horaria
        reservaRequest.setHoraInicio(LocalTime.of(15, 0));
        reservaRequest.setHoraFinal(LocalTime.of(16, 0));
    }
    @Nested
    @DisplayName("Pruebas para reservarTutoria (HU8)")
    class ReservarTutoriaTests {
        @Test
        @DisplayName("Debe crear una reserva exitosamente si todas las condiciones se cumplen")
        void reservarTutoria_whenSuccessful_shouldCreateAndReturnSession() {
            LocalDateTime inicioSesion = LocalDateTime.of(reservaRequest.getFecha(), reservaRequest.getHoraInicio());
            LocalDateTime finSesion = LocalDateTime.of(reservaRequest.getFecha(), reservaRequest.getHoraFinal());
            Disponibilidad disp = new Disponibilidad();
            when(estudianteRepository.findByUserEmail(alumnoEmail)).thenReturn(Optional.of(mockAlumno));
            when(tutorRepository.findById(reservaRequest.getTutorId())).thenReturn(Optional.of(mockTutor));
            when(disponibilidadRepository.findDisponibilidadQueEnvuelveElSlot(anyLong(), any(), any(), any())).thenReturn(List.of(disp));
            when(sesionRepository.findSesionesSolapadasParaTutor(anyLong(), any(), any(), any())).thenReturn(Collections.emptyList());
            when(sesionRepository.findSesionesSolapadasParaEstudiante(anyLong(), any(), any(), any())).thenReturn(Collections.emptyList());
            when(sesionRepository.save(any(Sesion.class))).thenAnswer(invocation -> invocation.getArgument(0));
            when(sesionMapper.toSesionResponse(any(Sesion.class))).thenReturn(new SesionResponse());
            SesionResponse result = sesionService.reservarTutoria(alumnoEmail, reservaRequest);
            assertNotNull(result);
            verify(sesionRepository).save(argThat(sesion ->
                    sesion.getTipoEstado() == EstadoSesionEnum.PENDIENTE &&
                            sesion.getTutor().getId().equals(mockTutor.getId()) &&
                            sesion.getEstudiante().getId().equals(mockAlumno.getId())
            ));
        }
        @Test
        @DisplayName("Debe lanzar BadRequestException si el horario no está dentro de la disponibilidad")
        void reservarTutoria_whenTutorNotAvailable_shouldThrowBadRequest() {
            when(estudianteRepository.findByUserEmail(alumnoEmail)).thenReturn(Optional.of(mockAlumno));
            when(tutorRepository.findById(reservaRequest.getTutorId())).thenReturn(Optional.of(mockTutor));
            when(disponibilidadRepository.findDisponibilidadQueEnvuelveElSlot(anyLong(), any(), any(), any())).thenReturn(Collections.emptyList());
            BadRequestException exception = assertThrows(BadRequestException.class, () -> {
                sesionService.reservarTutoria(alumnoEmail, reservaRequest);
            });
            assertEquals("El horario solicitado no está dentro de la disponibilidad del tutor.", exception.getMessage());
        }
        @Test
        @DisplayName("Debe lanzar BadRequestException si el horario ya está ocupado por otra sesión")
        void reservarTutoria_whenSlotIsBooked_shouldThrowBadRequest() {
            when(estudianteRepository.findByUserEmail(alumnoEmail)).thenReturn(Optional.of(mockAlumno));
            when(tutorRepository.findById(reservaRequest.getTutorId())).thenReturn(Optional.of(mockTutor));
            when(disponibilidadRepository.findDisponibilidadQueEnvuelveElSlot(anyLong(), any(), any(), any())).thenReturn(List.of(new Disponibilidad()));
            when(sesionRepository.findSesionesSolapadasParaTutor(anyLong(), any(), any(), any())).thenReturn(List.of(new Sesion()));
            BadRequestException exception = assertThrows(BadRequestException.class, () -> {
                sesionService.reservarTutoria(alumnoEmail, reservaRequest);
            });
            assertEquals("El horario seleccionado ya no está disponible o está ocupado.", exception.getMessage());
        }
        @Test
        @DisplayName("Debe lanzar ResourceNotFoundException si el tutor no existe")
        void reservarTutoria_whenTutorNotFound_shouldThrowResourceNotFound() {
            when(estudianteRepository.findByUserEmail(alumnoEmail)).thenReturn(Optional.of(mockAlumno));
            when(tutorRepository.findById(reservaRequest.getTutorId())).thenReturn(Optional.empty());
            assertThrows(ResourceNotFoundException.class, () -> {
                sesionService.reservarTutoria(alumnoEmail, reservaRequest);
            });
        }
        @Test
        @DisplayName("Debe lanzar BadRequestException si la hora final es anterior a la inicial")
        void reservarTutoria_whenEndTimeIsBeforeStartTime_shouldThrowBadRequest() {
            reservaRequest.setHoraFinal(LocalTime.of(9, 0)); // Hora fin < hora inicio (10:00)
            when(estudianteRepository.findByUserEmail(alumnoEmail)).thenReturn(Optional.of(mockAlumno));
            when(tutorRepository.findById(reservaRequest.getTutorId())).thenReturn(Optional.of(mockTutor));
            BadRequestException exception = assertThrows(BadRequestException.class, () -> {
                sesionService.reservarTutoria(alumnoEmail, reservaRequest);
            });
            assertEquals("La hora de finalización debe ser posterior a la hora de inicio.", exception.getMessage());
        }
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\test\java\tutorgo\com\service\TutorServiceImplTest.java
package tutorgo.com.service;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import tutorgo.com.dto.response.PagedResponse;
import tutorgo.com.dto.response.TutorProfileResponse;
import tutorgo.com.dto.response.TutorSummaryResponse;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.mapper.TutorMapper;
import tutorgo.com.model.Tutor;
import tutorgo.com.model.User;
import tutorgo.com.repository.TutorRepository;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;
@ExtendWith(MockitoExtension.class)
@DisplayName("Pruebas Unitarias para TutorServiceImpl")
class TutorServiceImplTest {
    @Mock
    private TutorRepository tutorRepository;
    @Mock
    private TutorMapper tutorMapper;
    @InjectMocks
    private TutorServiceImpl tutorService;
    private Pageable pageable;
    private Tutor mockTutor;
    private User mockUser;
    @BeforeEach
    void setUp() {
        pageable = PageRequest.of(0, 9);
        mockUser = User.builder().id(1L).nombre("Profesor de Cálculo").fotoUrl("http://example.com/foto.png").build();
        mockTutor = Tutor.builder()
                .id(1L)
                .user(mockUser)
                .rubro("Matemáticas")
                .bio("Experto en derivadas e integrales.")
                .estrellasPromedio(4.8f)
                .tarifaHora(100)
                .build();
    }
    @Nested
    @DisplayName("Pruebas para getAllTutores (HU7 con Filtros)")
    class GetAllTutoresTests {
        @Test
        @DisplayName("Debe llamar a searchWithFilters con filtros nulos si no se proveen")
        void getAllTutores_whenNoFilters_shouldCallRepositoryWithNulls() {
            Page<Tutor> tutorPage = new PageImpl<>(List.of(mockTutor));
            when(tutorRepository.searchWithFilters(null, null, null, pageable)).thenReturn(tutorPage);
            when(tutorMapper.tutorsToTutorSummaryResponseList(anyList())).thenReturn(List.of(new TutorSummaryResponse()));
            tutorService.getAllTutores(null, null, null, pageable);
            verify(tutorRepository).searchWithFilters(null, null, null, pageable);
            verify(tutorMapper).tutorsToTutorSummaryResponseList(anyList());
        }
        @Test
        @DisplayName("Debe llamar a searchWithFilters con todos los parámetros de filtro")
        void getAllTutores_withAllFilters_shouldCallRepositoryWithAllParameters() {
            String query = "Cálculo";
            Integer maxPrecio = 120;
            Float puntuacion = 4.5f;
            Page<Tutor> tutorPage = new PageImpl<>(List.of(mockTutor));
            when(tutorRepository.searchWithFilters(query, maxPrecio, puntuacion, pageable)).thenReturn(tutorPage);
            when(tutorMapper.tutorsToTutorSummaryResponseList(anyList())).thenReturn(List.of(new TutorSummaryResponse()));
            tutorService.getAllTutores(query, maxPrecio, puntuacion, pageable);
            verify(tutorRepository).searchWithFilters(query, maxPrecio, puntuacion, pageable);
        }
        @Test
        @DisplayName("Debe tratar una query en blanco como nula")
        void getAllTutores_whenQueryIsBlank_shouldBeTreatedAsNull() {
            String blankQuery = "   ";
            Page<Tutor> tutorPage = Page.empty(pageable);
            when(tutorRepository.searchWithFilters(eq(null), any(), any(), any(Pageable.class)))
                    .thenReturn(tutorPage);
            tutorService.getAllTutores(blankQuery, null, null, pageable);
            verify(tutorRepository).searchWithFilters(null, null, null, pageable);
        }
        @Test
        @DisplayName("Debe devolver una respuesta paginada vacía si la búsqueda no encuentra resultados")
        void getAllTutores_whenNoResultsFound_shouldReturnEmptyResponse() {
            String query = "Física Cuántica";
            Integer maxPrecio = 50;
            Float puntuacion = 5.0f;
            Page<Tutor> emptyPage = Page.empty(pageable);
            when(tutorRepository.searchWithFilters(eq(query), eq(maxPrecio), eq(puntuacion), any(Pageable.class)))
                    .thenReturn(emptyPage);
            PagedResponse<TutorSummaryResponse> result = tutorService.getAllTutores(query, maxPrecio, puntuacion, pageable);
            assertNotNull(result);
            assertTrue(result.getContent().isEmpty(), "El contenido de la respuesta debería estar vacío");
            assertEquals(0, result.getTotalElements());
            verify(tutorMapper, never()).tutorsToTutorSummaryResponseList(any());
        }
    }
    @Nested
    @DisplayName("Pruebas para getTutorProfile (HU16)")
    class GetTutorProfileTests {
        @Test
        @DisplayName("Debe devolver el perfil completo del tutor si el ID existe")
        void getTutorProfile_whenTutorExists_shouldReturnProfile() {
            when(tutorRepository.findById(1L)).thenReturn(Optional.of(mockTutor));
            TutorProfileResponse response = tutorService.getTutorProfile(1L);
            assertNotNull(response);
            assertEquals(mockTutor.getId(), response.getId());
            assertEquals(mockUser.getNombre(), response.getNombreUsuario());
            verify(tutorRepository).findById(1L);
        }
        @Test
        @DisplayName("Debe lanzar ResourceNotFoundException si el tutor no existe")
        void getTutorProfile_whenTutorNotFound_shouldThrowResourceNotFoundException() {
            Long nonExistentId = 99L;
            when(tutorRepository.findById(nonExistentId)).thenReturn(Optional.empty());
            assertThrows(ResourceNotFoundException.class, () -> tutorService.getTutorProfile(nonExistentId));
        }
    }
}
Full Path: C:\Users\imano\Documents\GitHub\tutorgo\tutorgo\src\test\java\tutorgo\com\service\UserServiceImplTest.java
package tutorgo.com.service;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.crypto.password.PasswordEncoder;
import tutorgo.com.dto.request.UpdatePasswordRequest;
import tutorgo.com.dto.request.UpdateUserProfileRequest;
import tutorgo.com.dto.request.UserRegistrationRequest;
import tutorgo.com.dto.response.StudentProfileResponse;
import tutorgo.com.dto.response.TutorProfileResponse;
import tutorgo.com.dto.response.UserResponse;
import tutorgo.com.enums.RoleName;
import tutorgo.com.exception.BadRequestException;
import tutorgo.com.exception.DuplicateResourceException;
import tutorgo.com.exception.ResourceNotFoundException;
import tutorgo.com.mapper.UserMapper;
import tutorgo.com.model.Estudiante;
import tutorgo.com.model.Role;
import tutorgo.com.model.Tutor;
import tutorgo.com.model.User;
import tutorgo.com.repository.EstudianteRepository;
import tutorgo.com.repository.RoleRepository;
import tutorgo.com.repository.TutorRepository;
import tutorgo.com.repository.UserRepository;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.Mockito.*;
@ExtendWith(MockitoExtension.class)
class UserServiceImplTest {
    @Mock
    private UserRepository userRepository;
    @Mock
    private RoleRepository roleRepository;
    @Mock
    private TutorRepository tutorRepository;
    @Mock
    private EstudianteRepository estudianteRepository;
    @Mock
    private PasswordEncoder passwordEncoder;
    @Mock
    private UserMapper userMapper;
    @InjectMocks
    private UserServiceImpl userService;
    private UserRegistrationRequest userRegistrationRequest;
    private UpdatePasswordRequest updatePasswordRequest;
    private UpdateUserProfileRequest updateUserProfileRequest;
    private Role studentRole;
    private Role tutorRole;
    private User user;
    private UserResponse userResponse;
    @BeforeEach
    void setUp() {
        userRegistrationRequest = new UserRegistrationRequest();
        userRegistrationRequest.setNombre("Test User Reg");
        userRegistrationRequest.setEmail("test.reg@example.com");
        userRegistrationRequest.setPassword("password123");
        userRegistrationRequest.setRol(RoleName.ESTUDIANTE);
        userRegistrationRequest.setCentroEstudio("Universidad Test Reg");
        studentRole = new Role(1, RoleName.ESTUDIANTE);
        tutorRole = new Role(2, RoleName.TUTOR);
        user = User.builder()
                .id(1L)
                .nombre("Test User Existing")
                .email("test.existing@example.com")
                .password("encodedPassword")
                .role(studentRole)
                .fotoUrl("http://example.com/old.jpg")
                .build();
        Estudiante studentProfile = Estudiante.builder().id(1L).user(user).centroEstudio("Centro Estudio Existente").build();
        user.setStudentProfile(studentProfile);
        updatePasswordRequest = new UpdatePasswordRequest();
        updatePasswordRequest.setCurrentPassword("oldPassword123");
        updatePasswordRequest.setNewPassword("newPassword456");
        updatePasswordRequest.setConfirmNewPassword("newPassword456");
        updateUserProfileRequest = new UpdateUserProfileRequest();
        updateUserProfileRequest.setNombre("Nuevo Nombre Perfil");
        updateUserProfileRequest.setFotoUrl("http://example.com/nueva_foto_perfil.jpg");
        userResponse = new UserResponse();
        userResponse.setId(1L);
        userResponse.setEmail(user.getEmail()); // Usar email del 'user' de prueba
        userResponse.setNombre(user.getNombre());
        userResponse.setRol(studentRole.getNombre());
        StudentProfileResponse spr = new StudentProfileResponse();
        spr.setId(studentProfile.getId());
        spr.setCentroEstudio(studentProfile.getCentroEstudio());
        userResponse.setStudentProfile(spr);
    }
    @Test
    void registerUser_Student_Success() {
        UserResponse specificUserResponse = new UserResponse();
        specificUserResponse.setId(1L);
        specificUserResponse.setEmail(userRegistrationRequest.getEmail());
        specificUserResponse.setNombre(userRegistrationRequest.getNombre());
        specificUserResponse.setRol(RoleName.ESTUDIANTE);
        StudentProfileResponse studentProfileResponse = new StudentProfileResponse();
        studentProfileResponse.setId(1L); // Asumir que el perfil de estudiante también obtiene un ID
        studentProfileResponse.setCentroEstudio(userRegistrationRequest.getCentroEstudio());
        specificUserResponse.setStudentProfile(studentProfileResponse);
        when(userRepository.existsByEmail(anyString())).thenReturn(false);
        when(roleRepository.findByNombre(RoleName.ESTUDIANTE)).thenReturn(Optional.of(studentRole));
        when(passwordEncoder.encode(anyString())).thenReturn("encodedPasswordReg");
        when(userRepository.save(any(User.class))).thenAnswer(invocation -> {
            User u = invocation.getArgument(0);
            u.setId(1L);
            if (u.getRole().getNombre() == RoleName.ESTUDIANTE) {
                Estudiante sp = Estudiante.builder().id(1L).user(u).centroEstudio(userRegistrationRequest.getCentroEstudio()).build();
                u.setStudentProfile(sp);
            }
            return u;
        });
        when(estudianteRepository.save(any(Estudiante.class))).thenAnswer(invocation -> {
            Estudiante e = invocation.getArgument(0);
            e.setId(1L);
            return e;
        });
        when(userMapper.userToUserResponse(any(User.class))).thenReturn(specificUserResponse);
        UserResponse result = userService.registerUser(userRegistrationRequest);
        assertNotNull(result);
        assertEquals(userRegistrationRequest.getEmail(), result.getEmail());
        assertEquals(RoleName.ESTUDIANTE, result.getRol());
        assertNotNull(result.getStudentProfile());
        assertEquals(userRegistrationRequest.getCentroEstudio(), result.getStudentProfile().getCentroEstudio());
        verify(userRepository, times(1)).save(any(User.class));
        verify(estudianteRepository, times(1)).save(any(Estudiante.class));
        verify(tutorRepository, never()).save(any(Tutor.class));
    }
    @Test
    void registerUser_Tutor_Success() {
        userRegistrationRequest.setRol(RoleName.TUTOR);
        userRegistrationRequest.setCentroEstudio(null);
        userRegistrationRequest.setTarifaHora(50);
        userRegistrationRequest.setRubro("Matemáticas");
        UserResponse specificUserResponse = new UserResponse();
        specificUserResponse.setId(2L);
        specificUserResponse.setEmail(userRegistrationRequest.getEmail());
        specificUserResponse.setNombre(userRegistrationRequest.getNombre());
        specificUserResponse.setRol(RoleName.TUTOR);
        TutorProfileResponse tutorProfileResponse = new TutorProfileResponse();
        tutorProfileResponse.setId(1L);
        tutorProfileResponse.setTarifaHora(50);
        tutorProfileResponse.setRubro("Matemáticas");
        specificUserResponse.setTutorProfile(tutorProfileResponse);
        when(userRepository.existsByEmail(anyString())).thenReturn(false);
        when(roleRepository.findByNombre(RoleName.TUTOR)).thenReturn(Optional.of(tutorRole));
        when(passwordEncoder.encode(anyString())).thenReturn("encodedPasswordRegTutor");
        when(userRepository.save(any(User.class))).thenAnswer(invocation -> {
            User u = invocation.getArgument(0);
            u.setId(2L);
            if (u.getRole().getNombre() == RoleName.TUTOR) {
                Tutor tp = Tutor.builder().id(1L).user(u).tarifaHora(userRegistrationRequest.getTarifaHora()).rubro(userRegistrationRequest.getRubro()).build();
                u.setTutorProfile(tp);
            }
            return u;
        });
        when(tutorRepository.save(any(Tutor.class))).thenAnswer(invocation -> {
            Tutor t = invocation.getArgument(0);
            t.setId(1L);
            return t;
        });
        when(userMapper.userToUserResponse(any(User.class))).thenReturn(specificUserResponse);
        UserResponse result = userService.registerUser(userRegistrationRequest);
        assertNotNull(result);
        assertEquals(RoleName.TUTOR, result.getRol());
        assertNotNull(result.getTutorProfile());
        assertEquals(50, result.getTutorProfile().getTarifaHora());
        verify(userRepository, times(1)).save(any(User.class));
        verify(tutorRepository, times(1)).save(any(Tutor.class));
        verify(estudianteRepository, never()).save(any(Estudiante.class));
    }
    @Test
    void registerUser_EmailAlreadyExists_ThrowsDuplicateResourceException() {
        when(userRepository.existsByEmail(userRegistrationRequest.getEmail())).thenReturn(true);
        DuplicateResourceException exception = assertThrows(DuplicateResourceException.class, () -> userService.registerUser(userRegistrationRequest));
        assertEquals("Este correo ya está registrado. Pruebe iniciando sesión.", exception.getMessage());
    }
    @Test
    void registerUser_TutorMissingTarifa_ThrowsBadRequestException() {
        userRegistrationRequest.setRol(RoleName.TUTOR);
        userRegistrationRequest.setTarifaHora(null);
        userRegistrationRequest.setRubro("Matemáticas");
        when(userRepository.existsByEmail(anyString())).thenReturn(false);
        when(roleRepository.findByNombre(RoleName.TUTOR)).thenReturn(Optional.of(tutorRole));
        when(passwordEncoder.encode(anyString())).thenReturn("encodedPassword");
        when(userRepository.save(any(User.class))).thenAnswer(invocation -> invocation.getArgument(0)); // Simula el guardado inicial
        BadRequestException exception = assertThrows(BadRequestException.class, () -> userService.registerUser(userRegistrationRequest));
        assertEquals("Para el rol TUTOR, la tarifa por hora y el rubro son obligatorios.", exception.getMessage());
        verify(userRepository, times(1)).delete(any(User.class)); // Verifica que se intenta borrar el usuario
    }
    @Test
    void updatePassword_Success() {
        when(userRepository.findByEmail(user.getEmail())).thenReturn(Optional.of(user));
        when(passwordEncoder.matches(updatePasswordRequest.getCurrentPassword(), user.getPassword())).thenReturn(true);
        when(passwordEncoder.matches(updatePasswordRequest.getNewPassword(), user.getPassword())).thenReturn(false);
        when(passwordEncoder.encode(updatePasswordRequest.getNewPassword())).thenReturn("encodedNewPassword");
        assertDoesNotThrow(() -> userService.updatePassword(user.getEmail(), updatePasswordRequest));
        verify(userRepository).save(argThat(savedUser -> savedUser.getPassword().equals("encodedNewPassword")));
    }
    @Test
    void updatePassword_CurrentPasswordInvalid_ThrowsBadRequestException() {
        when(userRepository.findByEmail(user.getEmail())).thenReturn(Optional.of(user));
        when(passwordEncoder.matches(updatePasswordRequest.getCurrentPassword(), user.getPassword())).thenReturn(false);
        BadRequestException exception = assertThrows(BadRequestException.class, () -> userService.updatePassword(user.getEmail(), updatePasswordRequest));
        assertEquals("La contraseña actual ingresada es incorrecta.", exception.getMessage());
    }
    @Test
    void updatePassword_NewPasswordsDoNotMatch_ThrowsBadRequestException() {
        updatePasswordRequest.setConfirmNewPassword("nonMatchingPassword");
        when(userRepository.findByEmail(user.getEmail())).thenReturn(Optional.of(user));
        when(passwordEncoder.matches(updatePasswordRequest.getCurrentPassword(), user.getPassword())).thenReturn(true);
        BadRequestException exception = assertThrows(BadRequestException.class, () -> userService.updatePassword(user.getEmail(), updatePasswordRequest));
        assertEquals("La nueva contraseña y su confirmación no coinciden.", exception.getMessage());
    }
    @Test
    void updatePassword_NewPasswordSameAsOld_ThrowsBadRequestException() {
        updatePasswordRequest.setNewPassword(updatePasswordRequest.getCurrentPassword()); // Hacerla igual
        updatePasswordRequest.setConfirmNewPassword(updatePasswordRequest.getCurrentPassword());
        when(userRepository.findByEmail(user.getEmail())).thenReturn(Optional.of(user));
        when(passwordEncoder.matches(updatePasswordRequest.getCurrentPassword(), user.getPassword())).thenReturn(true);
        when(passwordEncoder.matches(updatePasswordRequest.getNewPassword(), user.getPassword())).thenReturn(true);
        BadRequestException exception = assertThrows(BadRequestException.class, () -> {
            userService.updatePassword(user.getEmail(), updatePasswordRequest);
        });
        assertEquals("La nueva contraseña no puede ser igual a la contraseña actual.", exception.getMessage());
        verify(userRepository, never()).save(any());
    }
    @Test
    void updateUserProfile_Success_UpdatesNameAndFotoUrl() {
        UserResponse specificResponse = new UserResponse(); // Crear UserResponse específico
        specificResponse.setId(user.getId());
        specificResponse.setEmail(user.getEmail());
        specificResponse.setNombre(updateUserProfileRequest.getNombre());
        specificResponse.setFotoUrl(updateUserProfileRequest.getFotoUrl());
        specificResponse.setRol(user.getRole().getNombre());
        if (user.getStudentProfile() != null) {
            StudentProfileResponse spr = new StudentProfileResponse();
            spr.setId(user.getStudentProfile().getId());
            spr.setCentroEstudio(user.getStudentProfile().getCentroEstudio());
            specificResponse.setStudentProfile(spr);
        }
        when(userRepository.findByEmail(user.getEmail())).thenReturn(Optional.of(user));
        when(userRepository.save(any(User.class))).thenAnswer(invocation -> invocation.getArgument(0));
        when(userMapper.userToUserResponse(any(User.class))).thenReturn(specificResponse);
        UserResponse actualResponse = userService.updateUserProfile(user.getEmail(), updateUserProfileRequest);
        assertNotNull(actualResponse);
        assertEquals(updateUserProfileRequest.getNombre(), actualResponse.getNombre());
        assertEquals(updateUserProfileRequest.getFotoUrl(), actualResponse.getFotoUrl());
        verify(userRepository).save(argThat(savedUser ->
                savedUser.getNombre().equals(updateUserProfileRequest.getNombre()) &&
                        savedUser.getFotoUrl().equals(updateUserProfileRequest.getFotoUrl())
        ));
    }
    @Test
    void updateUserProfile_Success_UpdatesOnlyName_FotoUrlNullInRequest() {
        updateUserProfileRequest.setFotoUrl(null); // fotoUrl no se envía
        String originalFotoUrl = user.getFotoUrl(); // Guardar la foto original
        UserResponse specificResponse = new UserResponse();
        specificResponse.setId(user.getId());
        specificResponse.setEmail(user.getEmail());
        specificResponse.setNombre(updateUserProfileRequest.getNombre());
        specificResponse.setFotoUrl(originalFotoUrl); // Esperamos que la foto original se mantenga
        specificResponse.setRol(user.getRole().getNombre());
        if (user.getStudentProfile() != null) {
            StudentProfileResponse spr = new StudentProfileResponse();
            spr.setId(user.getStudentProfile().getId());
            spr.setCentroEstudio(user.getStudentProfile().getCentroEstudio());
            specificResponse.setStudentProfile(spr);
        }
        when(userRepository.findByEmail(user.getEmail())).thenReturn(Optional.of(user));
        when(userRepository.save(any(User.class))).thenAnswer(invocation -> invocation.getArgument(0));
        when(userMapper.userToUserResponse(any(User.class))).thenReturn(specificResponse);
        userService.updateUserProfile(user.getEmail(), updateUserProfileRequest);
        verify(userRepository).save(argThat(savedUser ->
                savedUser.getNombre().equals(updateUserProfileRequest.getNombre()) &&
                        (originalFotoUrl == null ? savedUser.getFotoUrl() == null : originalFotoUrl.equals(savedUser.getFotoUrl()))
        ));
    }
    @Test
    void updateUserProfile_Success_ClearsFotoUrl_IfFotoUrlEmptyInRequest() {
        updateUserProfileRequest.setFotoUrl(""); // Se envía fotoUrl vacía
        UserResponse specificResponse = new UserResponse();
        specificResponse.setId(user.getId());
        specificResponse.setEmail(user.getEmail());
        specificResponse.setNombre(updateUserProfileRequest.getNombre());
        specificResponse.setFotoUrl(null); // Esperamos que la foto se borre (sea null)
        specificResponse.setRol(user.getRole().getNombre());
        if (user.getStudentProfile() != null) {
            StudentProfileResponse spr = new StudentProfileResponse();
            spr.setId(user.getStudentProfile().getId());
            spr.setCentroEstudio(user.getStudentProfile().getCentroEstudio());
            specificResponse.setStudentProfile(spr);
        }
        when(userRepository.findByEmail(user.getEmail())).thenReturn(Optional.of(user));
        when(userRepository.save(any(User.class))).thenAnswer(invocation -> invocation.getArgument(0));
        when(userMapper.userToUserResponse(any(User.class))).thenReturn(specificResponse);
        userService.updateUserProfile(user.getEmail(), updateUserProfileRequest);
        verify(userRepository).save(argThat(savedUser ->
                savedUser.getNombre().equals(updateUserProfileRequest.getNombre()) &&
                        savedUser.getFotoUrl() == null
        ));
    }
    @Test
    void updateUserProfile_UserNotFound_ThrowsResourceNotFoundException() {
        when(userRepository.findByEmail("noexiste@example.com")).thenReturn(Optional.empty());
        assertThrows(ResourceNotFoundException.class, () -> userService.updateUserProfile("noexiste@example.com", updateUserProfileRequest));
    }
    @Test
    void deleteUserProfile_Success() {
        String userEmail = "user.to.delete@example.com";
        User userToDelete = User.builder().id(10L).email(userEmail).build();
        when(userRepository.findByEmail(userEmail)).thenReturn(Optional.of(userToDelete));
        doNothing().when(userRepository).delete(userToDelete);
        assertDoesNotThrow(() -> userService.deleteUserProfile(userEmail));
        verify(userRepository).findByEmail(userEmail);
        verify(userRepository).delete(userToDelete);
    }
    @Test
    void deleteUserProfile_UserNotFound_ThrowsResourceNotFoundException() {
        String userEmail = "non.existent.user@example.com";
        when(userRepository.findByEmail(userEmail)).thenReturn(Optional.empty());
        ResourceNotFoundException exception = assertThrows(ResourceNotFoundException.class, () -> {
            userService.deleteUserProfile(userEmail);
        });
        assertTrue(exception.getMessage().contains("Usuario no encontrado con email: " + userEmail));
        verify(userRepository, never()).delete(any(User.class));
    }
    @Test
    void deleteUserProfile_DeletionFails_ThrowsException() {
        String userEmail = "user.fail.delete@example.com";
        User userToFailDelete = User.builder().id(11L).email(userEmail).build();
        when(userRepository.findByEmail(userEmail)).thenReturn(Optional.of(userToFailDelete));
        doThrow(new RuntimeException("Error de base de datos simulado durante la eliminación"))
                .when(userRepository).delete(userToFailDelete);
        RuntimeException exception = assertThrows(RuntimeException.class, () -> {
            userService.deleteUserProfile(userEmail);
        });
        assertEquals("Error de base de datos simulado durante la eliminación", exception.getMessage());
        verify(userRepository).delete(userToFailDelete); // Se intentó eliminar
    }
}